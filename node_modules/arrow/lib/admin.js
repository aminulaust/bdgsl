/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var path = require('path'),
	fs = require('fs'),
	chalk = require('chalk'),
	dns = require('dns'),
	async = require('async'),
	adminapi = require('arrow-admin-api'),
	APIAdmin = require('arrow-admin'),
	APIAdmin2 = require('arrow-admin-ui'),
	om = require('arrow-objectmodel'),
	cluster = require('cluster'),
	async = require('async'),
	_ = require('lodash'),
	express = require('express'),
	ipfilter = require('express-ipfilter'),
	isipaddress = require('isipaddress'),
	util = require('./admin/util'),
	objectModel,
	admin;

// jscs:disable jsDoc
var DEFAULT_ALLOWED_HOSTS = ['127.0.0.1', '::1'];

function Admin() {}

Admin.prototype.resolveAllowedHosts = function resolveAllowedHosts(arrow, config, next) {
	if (config.allowedHosts) {
		config.allowedHosts = typeof config.allowedHosts === 'string' ? [config.allowedHosts] : config.allowedHosts;
		var allowedIps = [];
		var tasks = [];

		var lookup = function lookup(hostname, cb) {
			dns.lookup(hostname, {all: true}, function (err, addresses) {
				if (err) {
					arrow.logger.error('Error resolving ' + hostname, err);
					return cb(err);
				}
				addresses.forEach(function (detail) {
					arrow.logger.trace('Resolved ' + hostname + ' to ' + detail.address);
					allowedIps.push(detail.address);
				});
				cb();
			});
		};

		config.allowedHosts.forEach(function (host) {
			if (isipaddress.test(host)) {
				allowedIps.push(host);
			} else {
				tasks.push(function (cb) { lookup(host, cb); });
			}
		});

		async.series(tasks, function (err) {
			next(err, allowedIps);
		});
	} else {
		next(null, DEFAULT_ALLOWED_HOSTS);
	}
};

Admin.prototype.getAccessControlMiddleware = function getAccessControlMiddleware(arrow, allowedIps) {
	var ipfilterMiddleware = ipfilter.IpFilter(
		allowedIps,
		{
			mode: 'allow',
			logF: arrow.logger.warn.bind(arrow.logger),
			logLevel: 'deny'
		}
	);

	// Return a 403 on IpDeniedError
	var filter = function filter(req, res, next) {
		var nextWithErrCheck = function (err, result) {
			if (err && err instanceof ipfilter.IpDeniedError) {
				res.status(403).send();
			} else {
				next(err, result);
			}
		};
		ipfilterMiddleware(req, res, nextWithErrCheck);
	};

	return filter;
};

/**
 * start the admin
 */
Admin.prototype.start = function (arrow, callback) {
	var app = arrow.app,
		prefix = arrow.config.admin.prefix || '/arrow',
		apiprefix = '/adminapi/v1',
		createprefix = '/console',
		apiDocPrefix = '/apidoc',
		env = arrow.config.env,
		devmode = env === 'development',
		config = _.merge({
			apikey: arrow.config.apikey,
			apikey_production: arrow.config.apikey_production,
			apikey_preproduction: arrow.config.apikey_preproduction,
			apikey_development: arrow.config.apikey_development,
			routes: {},
			prefix: prefix,
			apiprefix: apiprefix,
			createprefix: createprefix,
			apiDocPrefix: apiDocPrefix,
			env: env
		}, arrow.config.admin || {});
	var self = this;
	this.prefix = prefix;
	this.apiprefix = apiprefix;
	this.createprefix = createprefix;

	if (cluster.isWorker) {
		// this is just used for hashing so create a directory that is hashed
		// so that we don't have conflicts generating the documentation cache
		// with multiple workers trying to generate the same doc
		config.docsDir = String(cluster.worker.id);
	}

	// admin is completely disabled
	if (config.disableAuth && config.disableAPIDoc) {
		arrow.logger.info('API Builder Console and API docs are disabled');
		return callback();
	}

	if (devmode || config.enableAdminInProduction) {
		require('./admin/logs').configure(app, prefix, arrow, devmode);
		require('./admin/timeline').configure(app, prefix, arrow, devmode);
		require('./admin/testapi').configure(app, prefix, arrow, devmode);
	}

	// for now, only generate in development or if explicitly enabled
	if (devmode || config.enableAdminInProduction) {

		// create the object model
		objectModel = new om.ObjectModel(arrow);

		// support fetching the object model from url
		app.get(prefix + '/isloggedin', function (req, resp) {
			return resp.json(util.isLoggedIn(req, arrow.config.session.secret));
		});

		// support fetching the object model from url
		app.get(prefix + '/objectmodel', function (req, resp) {
			// must either be local or logged in
			if (devmode || util.isLoggedIn(req, arrow.config.session.secret)) {
				//TODO: remove passwords
				return resp.json(objectModel);
			} else {
				// not allowed
				return util.unauthorized(resp);
			}
		});

		var testmsg;
		if (devmode && !config.enableAdminInProduction) {
			testmsg = chalk.grey('This will only be available on your dev environment. To enable in production, set ') + chalk.cyan('enableAdminInProduction') + chalk.grey(' in your config');
		} else if (!devmode && config.enableAdminInProduction) {
			testmsg = chalk.grey('Limited features are available in production.');
		}

		// set the baseurl for the server
		objectModel.baseurl = arrow.baseurl;
		objectModel.adminurl = arrow.adminurl;
		objectModel.apidocurl = arrow.apidocurl;

		async.series([
			function registerAccessControl(cb) {
				self.resolveAllowedHosts(arrow, config, function (err, result) {
					if (err) {
						return cb(err);
					} else if (result && result.length > 0) {
						// Restrict access to the Admin to the specified IPs.
						arrow.logger.info('Access to API Builder Console and Admin interface restricted to: ' + chalk.yellow(result.join(', ')));
						var accessFilter = self.getAccessControlMiddleware(arrow, result);
						app.use(config.prefix, accessFilter);
						app.use(config.apiprefix, accessFilter);
						app.use(config.createprefix, accessFilter);
					} else {
						arrow.logger.warn('Unrestricted access to API Builder Console and Admin interface.');
					}
					cb();
				});
			},
			function configureAdminAPI(cb) {
				if (devmode) {
					// configure admin api module
					adminapi.configure(app, apiprefix, arrow, devmode);
				}
				cb();
			},
			function (cb) {
				if (devmode) {
					var admin2 = new APIAdmin2(express, arrow, app, objectModel, config, null, function (err) {
						arrow.logger.info('Access the new API Builder Console at ' + chalk.yellow.underline(arrow.baseurl + createprefix) + '. ' + chalk.grey('This will only be available on your dev environment.'));
						cb(err);
					});
				} else {
					cb(); // No API Builder Console in production
				}
			},

			function (cb) {
				// load admin after any routes you want to execute before
				admin = new APIAdmin(express, arrow, app, objectModel, config, null, function (err) {
					if (!err) {
						// only allow reloading in development
						if (devmode) {
							// fired by the admin to reload the configuration and regenerate the docs, etc.
							arrow.on('reloaded', function (obj, err) {
								if (!err) {
									arrow.logger.info('API Builder Tools reloaded');
									objectModel = new om.ObjectModel(arrow);
									admin.emit('reload', objectModel);
								} else {
									arrow.logger.error('API Builder Tools reload error', err);
								}
							});
						}

						if (!config.disableAuth) {
							arrow.logger.info('The Legacy Arrow builder admin is now deprecated; it may still be accessed at ' + chalk.yellow.underline(arrow.adminurl) + (testmsg ? '. ' + testmsg : ''));
						}
						if (!config.disableAPIDoc) {
							arrow.logger.info('Access the swagger API documentation at ' + chalk.yellow.underline(arrow.baseurl + config.apiDocPrefix + '/swagger.json'));
						}
					}
					cb(err);
				});
			}

		], callback);

	} else {
		callback();
	}
};

module.exports = Admin;
