// jscs:disable jsDoc
var _ = require('lodash');
var om = require('arrow-objectmodel');
var Swagger = require('openapi-doc');

var verbMap = {
	POST: 'create',
	GET: 'find',
	PUT: 'update',
	DELETE: 'delete'
};

module.exports.bindRoutes = bindRoutes;
module.exports.generateSwagger = generateSwagger;

function bindRoutes(arrow) {
	var adminConfig = arrow.config.admin || {};
	var routePrefix = adminConfig.prefix || '/arrow';
	var app = arrow.app;

	arrow.logger.trace('Registering swagger routes under path ' + routePrefix);
	app.get(routePrefix + '/docs.json', getDefinition);
	app.get(routePrefix + '/swagger.json', getDefinition);
	if (adminConfig.disableAPIDoc === false) {
		var docsRoutePrefix = adminConfig.apiDocPrefix || '/apidoc';
		arrow.logger.trace('Registering swagger routes under path ' + docsRoutePrefix);
		app.get(docsRoutePrefix + '/docs.json', getDefinition);
		app.get(docsRoutePrefix + '/swagger.json', getDefinition);
	}

	var objectModel = new om.ObjectModel(arrow);
	function getDefinition(req, res) {
		var keys = Object.keys(req.query),
			host = objectModel.server.host ? objectModel.server.host : (req.get('host') || ('127.0.0.1' + (objectModel.server.port ? ':' + objectModel.server.port : ''))),
			name,
			type,
			result;
		// extract name and type. eg. ?apis/appc.arrowdb/acl (type=apis, name=appc.arrowdb/acl)
		if (keys.length) {
			type = keys[0].split('/')[0];
			name = keys[0].substr(type.length + 1, keys[0].length).replace(/\.(json|html)/g, '');
		}
		result = generateSwagger(arrow, host, objectModel, type, name);
		if (typeof result === 'number') {
			res.sendStatus(result);
		} else {
			res.set('Content-Type', 'application/json');
			res.send(result);
		}
	}
}

function generateSwagger(arrow, host, objectModel, type, name) {
	var swagger = new Swagger(),
		om;
	// Set the swagger API info
	swagger.info(
			objectModel.metadata.name || 'API',
			objectModel.metadata.version || '1.0',
			objectModel.metadata.description || 'API description')
		.host(
			objectModel.server.host ? objectModel.server.host : (host || ('127.0.0.1' + (objectModel.server.port ? ':' + objectModel.server.port : ''))))
		.basePath(objectModel.config.apiPrefix)
		.schemes(createSchemes(objectModel));

	// Security definition (see: arrow/lib/authentication/index.js)
	if (!arrow || !arrow.config.APIKeyAuthType || ['basic', 'ldap'].indexOf(arrow.config.APIKeyAuthType) >= 0) {
		swagger.securityDefinition('basicAuth', {
			type: 'basic',
			description: 'Require authorized access to API'
		})
		.security('basicAuth');
	} else if (arrow.config.APIKeyAuthType === 'apikey') {
		swagger.securityDefinition('apikey', {
			type: 'apiKey',
			name: 'apikey',
			in: 'header',
			description: 'Require authorized access to API'
		})
		.security('apikey');
	} else if (['saml', 'plugin'].indexOf(arrow.config.APIKeyAuthType) >= 0) {
		arrow.logger.log('unsupported swagger security definition: ' + arrow.config.APIKeyAuthType);
	}

	objectModel.metadata.author && swagger.contact(objectModel.metadata.author);
	objectModel.metadata.license && swagger.license(objectModel.metadata.license);
	objectModel.metadata.termsOfService && swagger.termsOfService(objectModel.metadata.termsOfService);

	// return 404 for undefined name or invalid types
	if (type && (!name || ['apis', 'endpoints'].indexOf(type) === -1)) {
		return 404;
	}

	// Merge in the valid enabled endpoints
	if (!type || type === 'endpoints') {
		if (arrow && arrow.endpoints) {
			if (type && Object.keys(arrow.endpoints).indexOf(name) === -1) {
				return 404;
			}
			Object.keys(arrow.endpoints).forEach(function (epName) {
				const xEnabled = arrow.endpoints[epName]['x-enabled'];
				if ((xEnabled && xEnabled.enabled) && (!type || epName === name)) {
					swagger.merge(arrow.endpoints[epName], arrow.endpoints[epName].basePath);
				}
			});
		}
	}

	// Merge in the model endpoints
	if (!type || type === 'apis') {
		if (type) {
			om = _.clone(objectModel);
			var transQuery = transformKeyForComparison(name); // lower-case
			var matchesQuery = function (value, key) {
				return transformKeyForComparison(key) === transQuery;
			};
			om.apis = pickBy(om.apis, matchesQuery);
			om.models = pickBy(om.models, matchesQuery);
			if (!Object.keys(om.apis).length) {
				return 404;
			}
		} else {
			om = objectModel;
		}
		if (om && om.apis && Object.keys(om.apis).length) {
			swagger.consumes([
				'application/json',
				'application/x-www-form-urlencoded',
				'multipart/form-data'
			]);
			swagger.produces([
				'application/json',
				'application/xml',
				'text/yaml',
				'text/csv',
				'text/plain'
			]);
			swagger.schemas(createDefinitions(om));
			swagger.paths(createPaths(om));
		}
	}
	return swagger.apidoc();
}

function transformKeyForComparison(val) {
	return val.replace(/[^a-z0-9]/ig, '').toLowerCase();
}

function createDefinitions(objectModel) {
	var retVal = {},
		models = objectModel.models;

	for (var modelName in models) {
		if (models.hasOwnProperty(modelName)) {
			var model = models[modelName],
				safeName = modelName.replace(/\//g, '_'),
				required = [],
				properties = {};

			for (var fieldName in model.fields) {
				if (model.fields.hasOwnProperty(fieldName)) {
					var field = model.fields[fieldName];
					if (field.required) {
						required.push(fieldName);
					}
					properties[fieldName] = {};
					switch (field.type) {
						case 'number':
							properties[fieldName].type = 'integer';
							properties[fieldName].format = 'int32';
							break;
						case 'array':
							// TODO: We need more information about the array sub-type here.
							properties[fieldName].type = 'array';
							properties[fieldName].items = {type: 'string'};
							break;
						case 'string':
							properties[fieldName].type = 'string';
							break;
						case 'boolean':
							properties[fieldName].type = 'boolean';
							break;
						case 'date':
							properties[fieldName].type = 'string';
							properties[fieldName].format = 'date';
							break;
						case 'object':
							properties[fieldName].type = 'string';
							properties[fieldName].format = 'json';
							break;
						default:
							properties[fieldName].type = 'string';
							properties[fieldName].format = field.type;
							break;
					}
				}
			}

			retVal[safeName] = {
				type: 'object',
				properties: properties
			};
			if (required.length > 0) {
				retVal[safeName].required = required;
			}
		}
	}

	retVal.ResponseModel = {
		type: 'object',
		required: [
			'code',
			'success',
			'request-id'
		],
		properties: {
			code: {
				type: 'integer',
				format: 'int32'
			},
			success: {
				type: 'boolean',
				'default': false
			},
			'request-id': {
				type: 'string'
			},
			message: {
				type: 'string'
			},
			url: {
				type: 'string'
			}
		}
	};

	retVal.ErrorModel = {
		type: 'object',
		required: [
			'message',
			'code',
			'success',
			'request-id'
		],
		properties: {
			code: {
				type: 'integer',
				format: 'int32'
			},
			success: {
				type: 'boolean',
				default: false
			},
			'request-id': {
				type: 'string'
			},
			message: {
				type: 'string'
			},
			url: {
				type: 'string'
			}
		}
	};

	return retVal;
}

function createPaths(objectModel) {
	var retVal = {},
		apis = objectModel.apis;
	for (var groupName in apis) {
		if (apis.hasOwnProperty(groupName)) {
			var api = apis[groupName];
			for (var i = 0; i < api.endpoints.length; i++) {
				var endpoint = api.endpoints[i],
					relativePath = translatePath(endpoint.path.split(objectModel.config.apiPrefix).pop()),
					def = retVal[relativePath];
				if (endpoint.enabled === false) {
					continue;
				}
				if (!def) {
					retVal[relativePath] = def = {};
				}
				var pathID = endpoint.method.toLowerCase();
				def[pathID] = compact({
					description: endpoint.description,
					operationId: getOperationId(endpoint),
					deprecated: endpoint.deprecated,
					parameters: translateParameters(endpoint),
					responses: endpoint.responses || api.responses,
					tags: [groupName]
				});
				if (!def[pathID].responses) {
					def[pathID].responses = {
						default: {
							description: 'Response from Server',
							schema: {
								$ref: '#/definitions/ResponseModel'
							}
						}
					};
				}
			}
		}
	}
	return retVal;
}

function createSchemes(objectModel) {
	var retVal = ['http'],
		config = objectModel.config || {};

	if (config.ssl && (config.env === 'development' || config.sslInProduction)) {
		retVal.push('https');
	}
	return retVal;
}

function translatePath(path) {
	return path.replace(/:([^/]+)/g, '{$1}');
}

function translateParameters(endpoint) {
	var retVal = [],
		bodyParams;
	if (_.find(endpoint.parameters, {type: 'body'})) {
		bodyParams = {
			name: endpoint.nickname,
			'in': 'body',
			description: endpoint.nickname + ' body',
			schema: {
				type: 'object',
				required: [],
				properties: {}
			}
		};
	}
	for (var name in endpoint.parameters) {
		if (endpoint.parameters.hasOwnProperty(name)) {
			var param = endpoint.parameters[name];
			switch (param.type) {
				case 'body':
					if (param.required) {
						bodyParams.schema.required.push(name);
					}
					bodyParams.schema.properties[name] = transformArrowProperty(param);
					break;
				default:
					if (param.type === 'form') {
						// We can't define both body and form params; there can be only one body per endpoint.
						if (bodyParams) {
							if (param.required) {
								bodyParams.schema.required.push(name);
							}
							bodyParams.schema.properties[name] = transformArrowProperty(param);
							break;
						}
					}
					// Force form parameters to be required (as required by the Swagger spec).
					if (param.type === 'path') {
						param.required = true;
					}
					var translated = {
						name: name,
						'in': param.type,
						description: param.description,
						required: !!param.required,
						type: param.dataType || 'string'
					};
					// TODO: We need more information about the sub-types of objects and arrays.
					if (param.dataType === 'object') {
						translated.type = 'string';
					}
					if (param.dataType === 'array') {
						translated.items = {type: 'object'};
					}
					retVal.push(compact(translated));
					break;
			}
		}
	}
	if (bodyParams) {
		if (bodyParams.schema.required.length === 0) {
			delete bodyParams.schema.required;
		}
		retVal.push(bodyParams);
	}
	return retVal;
}

function transformArrowProperty(arrowProperty) {
	var dataType = arrowProperty.dataType || 'string';
	var swaggerProperty = {
		type: dataType,
		description: arrowProperty.description
	};
	switch (dataType) {
		case 'date':
			swaggerProperty.type = 'string';
			swaggerProperty.format = 'date';
			break;
		case 'array': {
			swaggerProperty.items = {type: 'string'};
			break;
		}
	}

	return swaggerProperty;
}

function getOperationId(endpoint) {
	var retVal = verbMap[endpoint.method] || endpoint.method.toLowerCase(),
		splits = endpoint.path.replace(/appc\./, '')
			.replace(/_[a-z]/ig, function (val) {
				return val[1].toUpperCase();
			})
			.slice(1).split('/');
	for (var i = 1; i < splits.length; i++) {
		var split = splits[i];
		if (split[0] === ':') {
			retVal += 'By' + split.slice(1).toUpperCase();
		} else if (split[0] !== undefined) {
			retVal += split[0].toUpperCase() + split.slice(1);
		}
	}
	return retVal;
}

function compact(obj) {
	return omitBy(obj, function (val, key) {
		if (_.isArray(val)) {
			return val.length === 0;
		}
		if (_.isObject(val)) {
			obj[key] = compact(val);
			if (_.keys(obj[key]).length === 0) {
				return false;
			}
		}

		return !val;
	});
}

/**
 * Emulates the behaviour of _.omitBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#omitBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function omitBy(obj, predicate) {
	return pickBy(obj, _.negate(_.iteratee(predicate)));
}

/**
 * Emulates the behaviour of _.pickBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#pickBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function pickBy(obj, predicate) {
	var index = -1;
	var props = _.keysIn(obj);
	var length = props.length;
	var result = {};

	while (++index < length) {
		var key = props[index];
		var value = obj[key];

		if (predicate(value, key)) {
			result[key] = value;
		}
	}
	return result;
}
