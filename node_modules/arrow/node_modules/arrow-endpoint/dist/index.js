'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-mixed-operators:0 */
/* eslint no-unused-expressions:0 */
/* eslint no-unused-vars:0 */
/* eslint no-console:0 */
var chalk = require('chalk');
var fs = require('fs');
var tools = require('swagger-tools');
var swaggerMetadata = require('swagger-tools/middleware/swagger-metadata');
var swaggerValidator = require('swagger-tools/middleware/swagger-validator');
var jsonlint = require('json-lint');

var PATH_PATTERN = new RegExp(/(?:\{[\w]+\})/g);

var Endpoints = function () {
	function Endpoints() {
		_classCallCheck(this, Endpoints);
	}

	_createClass(Endpoints, null, [{
		key: 'load',

		/**
   * Loads and validates an endpoint from a given file directory
   *
   * @static
   * @param {string} file - file path of the endpoint to be loaded
   * @param {array} flows - the array of available flows (used in validation)
   * @returns {object} promise - resolves to give the loaded endpoint
   *
   * @memberOf Endpoints
   */
		value: function load(file, flows) {
			var promise = new Promise(function (resolve, reject) {
				return fs.readFile(file, function (err, data) {
					if (err) {
						reject(err);
						return;
					}
					// Check if its a valid JSON
					var parsed = void 0;
					try {
						var lint = jsonlint(data.toString());
						if (lint.error) {
							throw new Error('failed to parse JSON file ' + file + ', line ' + lint.line + ', character ' + lint.character);
						}
						parsed = JSON.parse(data.toString());
					} catch (ex) {
						reject(ex);
						return;
					}
					// check if its a valid swagger definition
					var spec = tools.specs.v2;
					spec.validate(parsed, function (error, result) {
						if (error) {
							reject(error);
							return;
						}
						if (result && result.errors.length) {
							reject(result);
							return;
						}
						// check flow dependent validity
						parsed = Endpoints.validate(parsed, flows);
						resolve(parsed);
					});
				});
			});
			return promise;
		}

		/**
   * validates a given endpoint for internal errors. Flows are required in validation.
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @param {array} flows - the array of available flows (used in validation)
   * @returns {object} endpoint - validated endpoint's definition
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'validate',
		value: function validate(endpoint, flows) {
			Object.keys(endpoint.paths).forEach(function (path) {
				Object.keys(endpoint.paths[path]).forEach(function (method) {
					var flowName = endpoint.paths[path][method]['x-flow'];
					var msg = void 0;
					if (!flowName) {
						msg = 'Invalid Endpoint for path "' + method.toUpperCase() + ' ' + path + '": No flow name found.';
						endpoint = Endpoints.markInvalid(endpoint, msg);
					} else {
						var flow = flows[flowName];
						if (!flow) {
							msg = 'Invalid Endpoint for path "' + method.toUpperCase() + ' ' + path + '": flow "' + flowName + '" not found';
							endpoint = Endpoints.markInvalid(endpoint, msg);
						} else if (!flow['x-validation'] || !flow['x-validation'].valid) {
							msg = 'Invalid Endpoint for path "' + method.toUpperCase() + ' ' + path + '": flow "' + flowName + '" is not valid';
							endpoint = Endpoints.markInvalid(endpoint, msg);
						}
					}
				});
			});
			// if "enabled=true" on disk and/or not invalidated by the above conditions, then mark valid
			// if "enabled=false" on disk and not invalidated again by the above conditions, do nothing
			if (endpoint['x-enabled'] === undefined || endpoint['x-enabled'].enabled) {
				return Endpoints.markValid(endpoint);
			}
			return endpoint;
		}

		/**
   * marks a given endpoint valid and resets all the errors
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @returns {object} endpoint - the given endpoint's definition marked valid
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'markValid',
		value: function markValid(endpoint) {
			endpoint['x-enabled'] = {
				enabled: true,
				errors: []
			};
			return endpoint;
		}

		/**
   * marks a given endpoint invalid with a given error message.
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @param {string} error - error message to set
   * @returns {object} endpoint - the given endpoint's definition marked invalid
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'markInvalid',
		value: function markInvalid(endpoint) {
			var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unknown error';

			var errors = endpoint['x-enabled'] && endpoint['x-enabled'].errors ? endpoint['x-enabled'].errors : [];
			errors.push(error);
			endpoint['x-enabled'] = {
				enabled: false,
				errors: errors
			};
			return endpoint;
		}

		/**
   * Confirms a given endpoint's active status. Could've been manually disabled w/o any error
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @returns {boolean}
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'isEnabled',
		value: function isEnabled(endpoint) {
			return endpoint['x-enabled'] && endpoint['x-enabled'].enabled;
		}

		/**
   * Confirms a given endpoint's validity. Based on the presence of any error.
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @returns {boolean}
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'isValid',
		value: function isValid(endpoint) {
			return endpoint['x-enabled'] && (!endpoint['x-enabled'].errors || endpoint['x-enabled'].errors.length === 0);
		}

		/**
   * binds the given endpoints to the arrow's express app
   *
   * @static
   * @param {object} arrowInstance - the running arrow instance to be bound with
   * @param {object} endpoints - the endpoints to be bound
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'bind',
		value: function bind(arrowInstance, endpoints) {
			Object.keys(endpoints).forEach(function (endpointName) {
				var endpoint = endpoints[endpointName];
				if (!Endpoints.isEnabled(endpoint)) {
					var errors = endpoint['x-enabled'] && endpoint['x-enabled'].errors;
					errors && errors.forEach(function (errorMessage) {
						arrowInstance.logger.error(endpointName + ' - ' + errorMessage);
					});
					return;
				}

				var basePath = Endpoints.getRuntimeBasePath(arrowInstance, endpoint);
				var cloned = JSON.parse(JSON.stringify(endpoint));
				cloned.basePath = basePath;
				var swagerMetadataMiddleware = Endpoints.deserializeParameters(cloned);

				Object.keys(endpoint.paths).sort(function (left, right) {
					// Parameterized paths last
					var lParamCount = (left.match(/{/g) || []).length;
					var rParamCount = (right.match(/{/g) || []).length;

					if (lParamCount > rParamCount) {
						return lParamCount - rParamCount;
					}
					// shortest paths first
					return left > right;
				}).forEach(function (path) {
					var bindPath = Endpoints.endpointToExpress(basePath + path);
					var bound = false;
					// adding CORS headers
					arrowInstance.app.options(bindPath, Endpoints.addCors(arrowInstance, endpoint.paths[path]));
					Object.keys(endpoint.paths[path]).forEach(function (method) {
						arrowInstance.logger.debug('binding api (' + method + ')', bindPath);

						// Bind to the express path and apply middlewares
						var EPdefinition = endpoint.paths[path][method];
						arrowInstance.app[method](bindPath, Endpoints.authenticate(arrowInstance, EPdefinition), swagerMetadataMiddleware, Endpoints.validateParameters(), Endpoints.invokeFlow(arrowInstance, endpoint, EPdefinition));
						bound = true;
					});

					// Bind the error handler
					bound && arrowInstance.app.use(bindPath, function (err, req, res, next) {
						// logic
						if (res.statusCode < 400) {
							arrowInstance.logger.error(err);
							res.status(500);
						} else {
							arrowInstance.logger.debug(err);
						}
						res.send({ error: err.message });
					});
				});
			});
		}

		/**
   * Returns an Express middleware to add CORS headers to the response
   *
   * @static
   * @param {any} arrowInstance - the arrow instance
   * @param {any} endpointPathItemObj - the endpoint's path item object containing methods
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'addCors',
		value: function addCors(arrowInstance, endpointPathItemObj) {
			return function (req, res, next) {
				var options = Object.keys(endpointPathItemObj).map(function (i) {
					return i.toUpperCase();
				});
				var checkMethod = req.headers['access-control-request-method'];
				if (checkMethod && options.indexOf(checkMethod.toUpperCase()) < 0) {
					// to deny, just send 200 without CORS headers
					return res.status(200).end();
				}
				res.setHeader('Allow', options);
				arrowInstance.addCORsHeaders(arrowInstance.config, req, res);
				return res.status(200).end();
			};
		}

		/**
   * Returns an Express middleware to handle authentication.
   *
   * @static
   * @param {any} arrowInstance - the arrow instance
   * @param {object} EPdefinition - the endpoint's swagger definition
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'authenticate',
		value: function authenticate(arrowInstance, EPdefinition) {
			return function (req, res, next) {
				return arrowInstance.executeSecurityMiddleware(req, res, function (err) {
					if (err !== false) {
						next();
					}
				});
			};
		}

		/**
   * Returns an Express middleware to deserialize the swagger parameters from the express request.
   *
   * @static
   * @param {Arrow} arrowInstance - the arrow instance.
   * @param {object} EPdefinition - the endpoint's swagger definition
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'deserializeParameters',
		value: function deserializeParameters(endpoint) {
			return swaggerMetadata(endpoint);
		}

		/**
  	 * Returns an Express middleware that validates the swagger parameters.
  	 *
  	 * @static
  	 * @returns {function} Express middleware
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'validateParameters',
		value: function validateParameters() {
			return swaggerValidator();
		}

		/**
   * Returns an Express middleware to invoke flow
   *
   * @static
   * @param {object} arrowInstance - the arrow instance
   * @param {object} EPdefinition - the endpoint's swagger definition
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'invokeFlow',
		value: function invokeFlow(arrowInstance, endpoint, EPdefinition) {
			var produces = EPdefinition.produces || endpoint.produces;
			var flowName = EPdefinition['x-flow'];

			// A middleware closure to invoke flow
			return function (req, res, next) {
				if (produces && !req.accepts(produces)) {
					res.status(406).end();
				} else {
					// require flow response to match
					/*
     		status:
     		data:
     		headers: {key: value}
     */
					var data = {
						params: Endpoints.getFlowInput(req)
					};

					arrowInstance.flowManager.flow(flowName, data).then(function (result) {
						var status = +(result && result.status || 200);
						var resData = result && result.data;
						var headers = result && result.headers;

						// todo: cast responses to match schema or enforce schema
						if (headers) {
							Object.keys(headers).forEach(function (key) {
								arrowInstance.logger.debug(chalk.green('Setting header', key, headers[key]));
								res.setHeader(key, headers[key]);
							});
						}

						var dataString = '';

						res.status(status);
						if (resData !== undefined) {
							dataString = JSON.stringify(resData);
							res.setHeader('Content-Type', 'application/json');
							res.send(dataString);
						} else {
							res.send();
						}
						arrowInstance.logger.debug(chalk.green('Response', status, dataString));
					}).catch(function (err) {
						arrowInstance.logger.error(err);
						res.status(500).send({ error: 'Server Error' });
					});
				}
			};
		}

		/**
   * Converts an Swaggger endpoint path to an Express one.
   *
   * @static
   * @param {string} str - the endpoint path to convert.
   * @returns {string} The express path.
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'endpointToExpress',
		value: function endpointToExpress(str) {
			var match = PATH_PATTERN.exec(str);
			while (match != null) {
				str = str.replace(/{/, ':').replace(/}/, '');
				match = PATH_PATTERN.exec(str);
			}
			return str;
		}

		/**
   * Helper to get flow parameters from the swagger context
   * on the request.
  	 *
  	 * @static
  	 * @param {object} req - the Express request object.
  	 * @returns {object} A map of the deserialized parameters.
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'getFlowInput',
		value: function getFlowInput(req) {
			var data = {};
			if (req.swagger && req.swagger.params) {
				Object.keys(req.swagger.params).forEach(function (paramName) {
					var param = req.swagger.params[paramName];
					data[paramName] = param.value;
				});
			}
			return data;
		}

		/**
   * Get the runtime basepath.
  	 *
  	 * @static
  	 * @param {Arrow} arrow - the arrow instance.
   * @param {object} endpoint - the endpoint.
  	 * @returns {string} - the runtime basePath.
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'getRuntimeBasePath',
		value: function getRuntimeBasePath(arrow, endpoint) {
			var basePath = arrow.config.apiPrefix || '';

			var removeTrailingSlash = function removeTrailingSlash(str) {
				if (str.endsWith('/')) {
					return str.substring(0, str.length - 1);
				}
				return str;
			};

			if (endpoint.basePath) {
				if (endpoint.basePath.startsWith('/')) {
					basePath = removeTrailingSlash(basePath) + endpoint.basePath;
				} else {
					basePath += endpoint.basePath;
				}
				basePath = removeTrailingSlash(basePath);
			} else {
				basePath = removeTrailingSlash(basePath);
			}

			return basePath;
		}
	}]);

	return Endpoints;
}();

module.exports = Endpoints;