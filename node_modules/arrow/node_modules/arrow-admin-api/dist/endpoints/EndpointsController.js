'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-restricted-syntax:0 */
/* eslint no-unused-expressions:0 */
var async = require('async');
var fs = require('fs');
var path = require('path');
var safeFilename = require('./util').safeFilename;
var ModelEndpointGenerator = require('./ModelEndpointGenerator');
var BadRequestError = require('../errors/BadRequestError');
var NotFoundError = require('../errors/NotFoundError');

/**
 * The controller implementing the actions for interacting with Endpoints.
 * @public
 */

var EndpointsController = function () {
	/**
  * Create a ProjectController.
  * @param {object} ctx - The context for this controller.
  * @param {express} ctx.app - The express application.
  * @param {string} ctx.prefix - The prefix bound to.
  * @param {Arrow} ctx.arrow - The Arrow server.
  * @param {boolean} ctx.devmode - Flag indicating if this is a devmode server.
  * @param {Swagger} ctx.swagger - openapi-doc instance.
  */
	function EndpointsController(ctx) {
		_classCallCheck(this, EndpointsController);

		this.ctx = ctx;
		this.endpointsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'endpoints'));
		this.flowsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'flows'));
	}

	/**
  * Explict call to get the ModelGenerator to allow for easier testing.
  */


	_createClass(EndpointsController, [{
		key: '_createModelGenerator',
		value: function _createModelGenerator(modelName) {
			return new ModelEndpointGenerator(this.ctx.arrow, modelName);
		}

		/**
   * Generate the endpoint.
   */

	}, {
		key: 'generateEndpoints',
		value: function generateEndpoints(params) {
			var _this = this;

			return new Promise(function (resolve, reject) {
				if (params && params.name && params.model) {
					try {
						var safeName = safeFilename(params.name) + '.json';
						var endpointFilePath = path.join(_this.endpointsDir, safeName);

						var generator = _this._createModelGenerator(params.model);
						var endpointSwagger = generator.generateEndpoint(params.name, params.description);
						var flowDefinitions = generator.generateFlows(params.name);

						var fileData = [{ path: endpointFilePath, content: endpointSwagger }];
						Object.keys(flowDefinitions).forEach(function (name) {
							fileData.push({
								path: path.join(_this.flowsDir, name + '.json'),
								content: flowDefinitions[name]
							});
						});

						// Write the files
						var mkdirIfNotExists = function mkdirIfNotExists(dir, next) {
							fs.stat(dir, function (err, stats) {
								if (err) {
									if (err.code === 'ENOENT') {
										fs.mkdir(dir, 448, next);
									} else {
										next(err);
									}
								} else if (!stats.isDirectory()) {
									next(new Error(dir + ' is not a directory.'));
								} else {
									next();
								}
							});
						};

						var writeTasks = [function (next) {
							return mkdirIfNotExists(_this.endpointsDir, next);
						}, function (next) {
							return mkdirIfNotExists(_this.flowsDir, next);
						}];
						fileData.forEach(function (file) {
							writeTasks.push(function (next) {
								fs.writeFile(file.path, JSON.stringify(file.content, null, 2), {
									flag: 'w',
									encoding: 'utf-8',
									mode: 420
								}, function (err) {
									if (err) {
										next(err);
									} else {
										next();
									}
								});
							});
						});

						async.series(writeTasks, function (err) {
							if (err) {
								reject(err);
							} else {
								resolve(path.basename(endpointFilePath, path.extname(endpointFilePath)));
							}
						});
					} catch (err) {
						reject(err);
					}
				} else {
					reject(new BadRequestError());
				}
			});
		}

		/*
   * Returns an array of summaries (group name, endpoint count)
   * for each API group
   */

	}, {
		key: 'getEndpointSummaries',
		value: function getEndpointSummaries() {
			var _this2 = this;

			return new Promise(function (resolve) {
				var endpoints = _this2.ctx.arrow.getEndpoints();
				var summaries = Object.keys(endpoints).map(function (apiName) {
					var endpoint = endpoints[apiName];
					return {
						id: apiName,
						name: endpoint.info.title,
						endpointCount: Object.keys(endpoint.paths).map(function (a) {
							return Object.keys(endpoint.paths[a]).length;
						}).reduce(function (pre, cur) {
							return pre + cur;
						}),
						description: endpoint.info.description,
						status: !endpoint.hasOwnProperty('x-enabled') ? {
							enabled: true
						} : _extends({}, endpoint['x-enabled'])
					};
				});
				resolve(summaries);
			});
		}

		/**
   * Get API endpoints
   * @param {string} groupName - The name of the API endpoint group
   */

	}, {
		key: 'getEndpoints',
		value: function getEndpoints(groupName) {
			var _this3 = this;

			return new Promise(function (resolve, reject) {
				if (!groupName) {
					return reject(new BadRequestError());
				}
				var endpoints = _this3.ctx.arrow.getEndpoints();
				if (!endpoints.hasOwnProperty(groupName)) {
					return reject(new NotFoundError());
				}
				return resolve(endpoints[groupName]);
			});
		}
	}]);

	return EndpointsController;
}();

exports = module.exports = EndpointsController;