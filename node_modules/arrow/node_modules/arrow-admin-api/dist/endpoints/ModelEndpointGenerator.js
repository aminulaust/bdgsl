'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-restricted-syntax:0 */
/* eslint no-extra-boolean-cast:0 */
var Swagger = require('openapi-doc');
var NotFoundError = require('../errors/NotFoundError');
var safeFilename = require('./util').safeFilename;
var modelflows = require('./modelflows');

var ACTION_MAP = {
	findById: 'findByIDAPI',
	findOne: 'findByIDAPI'
};

/**
 * Helper for generating standard Endpoints from a Model definition.
 * @public
 */

var ModelEndpointGenerator = function () {
	function ModelEndpointGenerator(arrow, modelName) {
		_classCallCheck(this, ModelEndpointGenerator);

		this.arrow = arrow;
		this.logger = arrow.logger;
		this.model = arrow.getModel(modelName);

		if (!this.model) {
			throw new NotFoundError('Model ' + modelName + ' not found.');
		}
		this.supportedAPIs = this.getSupportedAPIDefs();
	}

	_createClass(ModelEndpointGenerator, [{
		key: 'getSupportedAPIDefs',
		value: function getSupportedAPIDefs() {
			var _this = this;

			var defs = {};

			// Reusing the existing CRUD->API support here
			// to get the metadata for Endpoint creation.
			for (var key in this.model) {
				// Limiting to CRUD APIs defined in Model base and not extended
				// APIs added by custom models/connectors.
				if (key.slice(-3) === 'API') {
					// Some connectors use old mappings, to maintain support remap to the standard action.
					var name = key.slice(0, -3);
					if (this.model[name] && Object.getPrototypeOf(this.model).hasOwnProperty(name)) {
						// Check to see if the underlying connector has the necessary methods to support this API.
						var apiDef = this.model[key]();
						var reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [name];
						var connectorMethods = reqConnectorMethods.filter(function (method) {
							return !!_this.model.getConnector()[method];
						});

						if (connectorMethods.length >= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
							var action = ACTION_MAP[name] || key;
							defs[action] = apiDef;
						} else {
							this.logger.warn('API not supported on Connector: ' + name);
						}
					} else {
						this.logger.warn('API not supported on Model: ' + name);
					}
				}
			}
			return defs;
		}

		/**
   * Generate the standard endpoints for the model.
   * @param {string} name - The endpoint name.
   * @param {string} description - The endpoint description.
   * @return {object} - The swagger object for the model endpoints.
   */

	}, {
		key: 'generateEndpoint',
		value: function generateEndpoint(name, description) {
			var _this2 = this;

			// Create the Swagger for each API supported by the model
			var swagger = new Swagger();
			swagger.info(name || (this.model.singular || this.model.name) + ' API', '1.0.0', description || '');

			swagger.schema.apply(swagger, _toConsumableArray(this.getDefinition(this.model)));
			if (this.arrow.config.endpointBasePath !== '') {
				swagger.basePath(this.arrow.config.endpointBasePath || '/endpoints');
			}

			Object.keys(this.supportedAPIs).forEach(function (apiName) {
				var apiDetail = _this2.supportedAPIs[apiName];
				var apiPath = _this2.getAPIPath(apiName);

				swagger[apiDetail.method.toLowerCase()](apiPath);
				swagger.operationId(_this2.getOperationId(_this2.model, apiPath, apiDetail));
				swagger.tag(_this2.model.name);
				swagger.extension('x-flow', _this2.getFlowName(name, apiName));
				swagger.description(apiDetail.description);
				swagger.consumes('application/json');
				swagger.produces('application/json');

				_this2.getParameters(apiDetail).forEach(function (param) {
					return swagger.parameter(param);
				});
				_this2.getResponses(apiDetail).forEach(function (res) {
					return swagger.response(res.code, res.description, res.schema, null, res.headers);
				});
			});

			return swagger.apidoc();
		}

		/**
   * Generate the standard flows for the model apis.
   * @param {string} endpointName - The name of the endpoint.
   * @return {object} - The map of flows to support the endpoint apis.
   */

	}, {
		key: 'generateFlows',
		value: function generateFlows(endpointName) {
			var _this3 = this;

			var flows = {};

			Object.keys(this.supportedAPIs).forEach(function (apiName) {
				var flowName = _this3.getFlowName(endpointName, apiName);

				if (modelflows.hasOwnProperty(apiName)) {
					flows[flowName] = modelflows[apiName](_this3.model);
				}
			});
			return flows;
		}

		/**
   * Get the appropriate name to use for the flow.
   */

	}, {
		key: 'getFlowName',
		value: function getFlowName(endpointName, apiName) {
			return safeFilename(endpointName) + '-' + apiName.slice(0, -3);
		}

		/**
   * Get the path for the model api.
   * @param {string} apiName - The api to get the path for.
   * @return {string} - The api path.
   */

	}, {
		key: 'getAPIPath',
		value: function getAPIPath(apiName) {
			var apiDetail = this.supportedAPIs[apiName];
			var name = this.model.name.replace(/^.*?\//, '').toLowerCase();
			var apiPath = '/' + name;
			if (apiDetail.path) {
				if (apiDetail.path.startsWith('./')) {
					apiPath += apiDetail.path.substr(1);
				} else {
					apiPath += apiDetail.path;
				}
			}
			return apiPath;
		}

		/**
   * Get the operation id.
   * @param {Model} model - The model the endpoints are being generated for.
   * @param {string} apiPath - The path the endpoint is going to advertise.
   * @param {object} apiDetail - The API details for the model method.
   * @return {string} - The operation id.
   */

	}, {
		key: 'getOperationId',
		value: function getOperationId(model, apiPath, apiDetail) {
			return apiDetail.nickname ? apiDetail.nickname + ' ' + model.singular : apiDetail.method + ' ' + apiPath;
		}

		/**
   * Get the swagger schema object definition for the model.
   * @param {Model} model - The model the endpoints are being generated for.
   * @return {array} - The first element is the name of the definition. The second element is
   *                   the schema object to add to the swagger.
   */

	}, {
		key: 'getDefinition',
		value: function getDefinition(model) {
			var _this4 = this;

			var safeName = model.name.replace(/\//g, '_');
			var required = [];
			var properties = {};

			Object.keys(model.fields).forEach(function (fieldName) {
				var field = model.fields[fieldName];

				properties[fieldName] = _extends({}, _this4.getParameterType(field.type, field.default, true), {
					description: field.description
				});

				if (field.required) {
					required.push(fieldName);
				}
			});

			return [safeName, {
				type: 'object',
				required: required.length > 0 ? required : undefined,
				properties: Object.keys(properties).length > 0 ? properties : undefined
			}];
		}

		/**
   * Map the model parameter type to the corresponding Swagger type and format.
   * @param {string} dataType - The arrow data type.
   * @param {string} defaultVal - The default value.
   * @param {boolean} inBody - The parameter encoding depends on the location, allow complex
   *                           types if a body param.
   * @param {object} - The swagger schema object fragment for type, default, items and format.
   */

	}, {
		key: 'getParameterType',
		value: function getParameterType(dataType, defaultVal, inBody) {
			var swaggerType = {};
			var hasDefault = defaultVal !== undefined && defaultVal !== null;

			switch (dataType) {
				case Number:
				case 'number':
					swaggerType.type = 'number';
					swaggerType.default = hasDefault ? parseFloat(defaultVal, 10) : undefined;
					break;
				case 'integer':
					swaggerType.type = 'integer';
					swaggerType.format = 'int32';
					swaggerType.default = hasDefault ? parseInt(defaultVal, 10) : undefined;
					break;
				case Array:
				case 'array':
					if (inBody) {
						swaggerType.type = 'array';
						swaggerType.items = {
							type: 'string'
						};
						if (hasDefault) {
							swaggerType.default = JSON.parse(defaultVal);
						}
					} else {
						swaggerType.type = 'string';
						swaggerType.format = 'json';
						swaggerType.default = hasDefault ? defaultVal : undefined;
					}
					break;
				case String:
				case 'string':
					swaggerType.type = 'string';
					swaggerType.default = hasDefault ? defaultVal : undefined;
					break;
				case Boolean:
				case 'boolean':
					swaggerType.type = 'boolean';
					swaggerType.default = hasDefault ? defaultVal.toLowerCase() === 'true' : undefined;
					break;
				case Date:
				case 'date':
					swaggerType.type = 'string';
					// An arrow date may be date or date-time, so can't reliably specify the format.
					// swaggerType.format = 'date';
					swaggerType.default = hasDefault ? defaultVal : undefined;
					break;
				case Object:
				case 'object':
					if (inBody) {
						swaggerType.type = 'object';
						if (hasDefault) {
							swaggerType.default = JSON.parse(defaultVal);
						}
					} else {
						swaggerType.type = 'string';
						swaggerType.format = 'json';
						swaggerType.default = hasDefault ? defaultVal : undefined;
					}
					break;
				default:
					if (typeof dataType === 'string') {
						swaggerType.format = dataType;
					} else if (typeof dataType === 'function') {
						swaggerType.format = dataType.name;
					}
					swaggerType.type = 'string';
					swaggerType.default = hasDefault ? defaultVal : undefined;
					break;
			}

			return swaggerType;
		}

		/**
   * Get the swagger fragment for the api parameters.
   * @param {object} apiDetail - The model API detail.
   * @return {object} - The swagger fragment for the endpoint parameters.
   */

	}, {
		key: 'getParameters',
		value: function getParameters(apiDetail) {
			if (!apiDetail.parameters) {
				return [];
			}

			return this.getPrologParameters(apiDetail).concat(this.getBodyParameters(apiDetail));
		}

		/**
   * Get the swagger fragment for the api header/query/path parameters.
   * @param {object} apiDetail - The model API detail.
   * @return {object} - The swagger fragment for the endpoint parameters.
   */

	}, {
		key: 'getPrologParameters',
		value: function getPrologParameters(apiDetail) {
			var _this5 = this;

			var params = [];
			// Query/Header/Path params
			Object.keys(apiDetail.parameters).filter(function (paramName) {
				return apiDetail.parameters[paramName].type !== 'body';
			}).forEach(function (paramName) {
				var param = apiDetail.parameters[paramName];

				params.push(_extends({
					in: param.type,
					name: paramName,
					description: param.description,
					required: !!param.required || param.type === 'path'
				}, _this5.getParameterType(param.dataType, param.default)));
			});
			return params;
		}

		/**
   * Get the swagger fragment for the api body parameters.
   * @param {object} apiDetail - The model API detail.
   * @return {object} - The swagger fragment for the endpoint parameters.
   */

	}, {
		key: 'getBodyParameters',
		value: function getBodyParameters(apiDetail) {
			var _this6 = this;

			var bodyParams = Object.keys(apiDetail.parameters).filter(function (name) {
				return apiDetail.parameters[name].type === 'body';
			});

			if (!bodyParams || bodyParams.length === 0) {
				return [];
			}

			var requiredParams = bodyParams.filter(function (name) {
				return apiDetail.parameters[name].required;
			});
			var swaggerParam = {
				name: this.model.name,
				in: 'body',
				description: apiDetail.nickname + ' body',
				schema: {
					type: 'object',
					additionalProperties: false,
					required: requiredParams.length > 0 ? requiredParams : undefined,
					properties: {}
				}
			};

			bodyParams.forEach(function (name) {
				var bodyParam = apiDetail.parameters[name];
				swaggerParam.schema.properties[name] = _extends({}, _this6.getParameterType(bodyParam.dataType, bodyParam.default, true), {
					description: bodyParam.description
				});
			});

			return [swaggerParam];
		}

		/**
   * Get the swagger fragment for the endpoint responses.
   * @param {object} apiDetail - The model API detail.
   * @return {object} - The swagger fragment for the endpoint responses.
   */

	}, {
		key: 'getResponses',
		value: function getResponses(apiDetail) {
			var responses = Object.keys(apiDetail.responses || {}).map(function (code) {
				return {
					code: code,
					description: apiDetail.responses[code].description,
					schema: apiDetail.responses[code].schema,
					headers: apiDetail.responses[code].headers
				};
			});

			// Standard responses
			if (apiDetail.parameters && (!apiDetail.responses || !apiDetail.responses[400])) {
				// If the api has parameters then input validation failure is always an option.
				responses.push({
					code: 400,
					description: 'Bad request.'
				});
			}

			responses.push({
				code: 401,
				description: 'This request requires user authentication, as configured by the server.'
			});
			responses.push({
				code: 404,
				description: 'No results were found.'
			});
			responses.push({
				code: 500,
				description: 'Something went wrong during the request; check out the logs on your server.'
			});
			return responses;
		}
	}]);

	return ModelEndpointGenerator;
}();

exports = module.exports = ModelEndpointGenerator;