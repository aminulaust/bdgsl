'use strict';

var path = require('path'),
    u = require('../util'),
    util = require('util'),
    fs = require('fs'),
    logger = require('../logger'),
    request = require('request'),
    HandleResult = require('./handleResult'),
    post = require('../post'),
    cli = require('../cli'),
    _ = require('underscore'),
    moment = require('moment'),
    url = require('url'),
    program = require('commander'),
    dockerUtil = require('../docker-util');

exports.run = function(args, program) {
    var globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if (proxy) {
        logger.debug('ACS CLI is using proxy: ' + proxy.server);
        proxy = proxy.url;
    }
    if (globalConfig.publishHost && !program.isCallback) {
        console.log(String(('Admin Hostname: ' + globalConfig.publishHost).grey));
    }

    u.getNpm(); //check if npm is installed, exit if not

    // attach our authentication
    var cookie = globalConfig.cookie ? String(globalConfig.cookie).split(';')[0] || ['connect-sid', ''].join('=') : '';

    var host = globalConfig.publishHost || defaultConfig.publishHost,
        port = globalConfig.publishPort || defaultConfig.publishPort,
        p = '/publish/',
        serverUrl = host + ':' + port + p;

    if (program.list_versions) {
        checkVersions();
    } else if (program.set_active_version) {
        changeVersion();
    } else if (program.app_version && program.image) {
        publishFromImage(); 
    } else {
        publishFromDir();
    }

    function checkVersions() {
        var name = program.list_versions === true ? null : program.list_versions,
            appname = u.getAppName(args, program, name);
        serverUrl += appname;

        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        serverUrl = url.format(parsedUrl);

        var HR = new HandleResult();
        HR.succeed = function(response, result) {
            console.log(result.message);
        };

        request({
            uri: encodeURI(serverUrl),
            method: 'GET',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HR.handler);
    }

    function changeVersion() {
        var appname = u.getAppName(args, program),
            version = program.set_active_version;
        serverUrl += appname + '/' + version;

        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        serverUrl = url.format(parsedUrl);

        var HRC = new HandleResult();
        HRC.checkResult = function(response, result) {
            if (!result.success) {
                if (result.message) {
                    u.die(result.message + ' ' + (result.extended || ''), result.errcode ? result.errcode : 1);
                } else {
                    u.die('Failed to validate the version: ' + result);
                }
            }
            program.confirm('Do you want to deploy version ' + version + ' published at ' + new Date(result.message) + '? ', function(ok) {
                if (ok) {
                    doChange();
                } else {
                    process.exit();
                }
            });
        };

        request({
            uri: encodeURI(serverUrl),
            method: 'GET',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HRC.handler);


        function doChange() {
            var HR = new HandleResult();
            request({
                uri: encodeURI(serverUrl),
                method: 'POST',
                proxy: proxy,
                headers: {
                    'Cookie': cookie,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }, HR.handler);
        }
    }

    function publishFromDir() {

        var dir = program.dir || process.cwd();

        var dockerfile = path.join(dir, 'Dockerfile');
        if (u.exists(dockerfile)) {
            var appversion = null, appname = null;
            appversion = program.app_version;
            appname = args[0];
            console.log(appversion);
            if (!appversion) {
                u.die('You must specify the app version to publish \'image\' type app');    
            }
            if (!appname) {
                u.die('You must specify the app name to publish \'image\' type app');    
            }

            var tmpImageRepoName = 'arrowcloud/' + appname + ':' + appversion;

            dockerUtil.buildDockerImage(tmpImageRepoName, dir, function(err) {
                if (err) {
                    u.die(err);
                }
                program.image = tmpImageRepoName;

                publishFromImage();
            });
        } else {

            var f = path.join(dir, 'package.json');
            if (!u.exists(f)) {
                u.die('Couldn\'t find app directory for publishing');
            }

            var config = {};
            // validate package.json

            var result = u.readAndValidateConfig(f);
            if (result.success === false) {
                u.die(result.message);
            }
            config = result.config;

            if (!config.version) {
                u.die('Please provide a valid version for your app in the package.json before continuing'.red);
            }
            var version = config.version;

            if (config.npmAuthentication === true) {
                var auth = u.getNPMAuth();
                if (auth && args.length === 0) {
                    doPublish(auth.user, auth.password);
                } else {
                    if (process.stdin.resume) {
                        process.stdin.resume();
                    }
                    u.getUsername(args, 'npm username:', function uncb(un) {
                        if (!un) {
                            u.getUsername(args, 'npm username:', uncb);
                            return;
                        }
                        u.getPassword(args, 'npm password:', function pwcb(pw) {
                            if (!pw) {
                                u.getPassword(args, 'npm password:', pwcb);
                                return;
                            }

                            doPublish(un, pw);
                        });
                    });
                }
            } else {
                doPublish();
            }
        }
            
        function doPublish(un, pw) {
            serverUrl += [config.name, config.version, (program.force ? 1 : 0)].join('/');
            var parsedUrl = url.parse(serverUrl);
            parsedUrl.query = {};
            if (program.org) {
                parsedUrl.query.orgid = program.org;
            }
            if (program.async) {
                parsedUrl.query.async = program.async;
            }
            if (program.delete_oldest) {
                parsedUrl.query.delete_oldest = program.delete_oldest;
            }
            serverUrl = url.format(parsedUrl);

            cli.spinner('Preparing application for publish...');

            var dirs = [dir];

            var HR = new HandleResult();
            HR.cli = cli;
            HR.reqParams = ['publish', args, program];
            HR.checkResult = function(response, result) {
                if (result.success) {
                    cli.spinner('Preparing application for publish... done\n', true);
                    publish(dirs, serverUrl, config, cookie, version, un, pw);
                } else {
                    // TODO, the string comparison here can probably be dropped
                    if (result.errcode === 201 || result.errcode === '201' ||
                        result.errcode === 'ENOEXISTS') {
                        // prompt for creating a new app
                        cli.spinner('Preparing application for publish... \n', true);
                        program.confirm('It looks like you don\'t have this app created on ArrowCloud yet. \nDo you want to create it for publishing now (yes/no)? ', function(ok) {
                            if (ok) {
                                console.log('Creating new Node.ACS app...');
                                var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                                    (globalConfig.publishPort || defaultConfig.publishPort) +
                                    '/create/' + config.name;
                                createNewApp(newAppURL, dirs, serverUrl, config, version, un, pw, null, null, 'dir', publish);
                            } else {
                                process.exit();
                            }
                        });
                    } else if (result.errcode === 212 || result.errcode === '212') {
                        handleTooManyVersions(result, dirs, serverUrl, config, version, un, pw, null, null, 'dir', publish);        
                    } else {
                        console.log();
                        u.die(result.message, result.errcode ? result.errcode : 1);
                    }
                }
            };

            request({
                uri: encodeURI(serverUrl),
                method: 'GET',
                proxy: proxy,
                headers: {
                    'Cookie': cookie,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }, HR.handler);
        }  
    }


    function publishFromImage() {
        var appname = null, orgid = null;
        if (args.length >= 1) {
            appname = args[0];
        } else {
            u.die('You must specify the app name to publish \'image\' type app');
        }
        var version = program.app_version,
            image = program.image;
        
        serverUrl += [appname, version, (program.force ? 1 : 0)].join('/');
        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        if (program.delete_oldest) {
            parsedUrl.query.delete_oldest = program.delete_oldest;
        }
        serverUrl = url.format(parsedUrl);

        cli.spinner('Preparing application for publish...');

        var HR = new HandleResult();
        HR.cli = cli;
        HR.reqParams = ['publish', args, program];
        HR.checkResult = function(response, result) {
            if (result.success) {
                cli.spinner('Preparing application for publish... done\n', true);
                pushImageAndPublish(serverUrl, appname, image, version);
            } else {
                // TODO, the string comparison here can probably be dropped
                if (result.errcode === 201 || result.errcode === '201' ||
                    result.errcode === 'ENOEXISTS') {
                    // TODO, the string comparison here can probably be dropped
                    if (result.errcode === 201 || result.errcode === '201' ||
                        result.errcode === 'ENOEXISTS') {
                        // prompt for creating a new app
                        cli.spinner('Preparing application for publish... \n', true);
                        program.confirm('It looks like you don\'t have this app created on ArrowCloud yet. \nDo you want to create it for publishing now (yes/no)? ', function(ok) {
                            if (ok) {
                                console.log('Creating new Node.ACS app...');
                                var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                                    (globalConfig.publishPort || defaultConfig.publishPort) +
                                    '/create/' + appname;
                                createNewApp(newAppURL, null, serverUrl, {name: appname}, version, null, null, null, image, 'image', pushImageAndPublish);
                            } else {
                                process.exit();
                            }
                        });
                    }    
                } else if (result.errcode === 212 || result.errcode === '212') {
                    handleTooManyVersions(result, null, serverUrl, {name: appname}, version, null, null, null, image, 'image', pushImageAndPublish);        
                } else {
                    console.log();
                    u.die(result.message, result.errcode ? result.errcode : 1);
                }
            }
        };

        request({
            uri: encodeURI(serverUrl),
            method: 'GET',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HR.handler);
    }

    function handleTooManyVersions(result, dirs, serverUrl, config, version, un, pw, configObj, image, where, callback) {
        var publishes = [], versions = []; 
        var separator = '\t';
        result.publishes.forEach(function(publish) {
            var tmpVersion = publish.version;
            versions.push(tmpVersion);
            if (publish.currentVersion === true) {
                tmpVersion += '\(*\)';
            }
            publishes.push(tmpVersion + separator + moment(publish.created_at).format() + separator + publish.publisher);
        });
        cli.spinner('Preparing application for publish... \n', true);
        console.log(result.message + ' You have to unpublish an old version to continue.');
        console.log('Please choose which version you want to unpublish(the one with * is the current version):');
        console.log('  Version\tPublished At\t\t\tPublished By');
        program.choose(publishes, function(i) {
            console.log('Unpublishing ' + versions[i] + ' of ' + config.name + '...');
            var unpublishURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                (globalConfig.publishPort || defaultConfig.publishPort) +
                '/unpublish/' + config.name + '/' + versions[i];
            unpublishApp(unpublishURL, dirs, serverUrl, config, version, un, pw, configObj, null, where, callback);
        });
    }

    function createNewApp(newAppURL, dirs, serverUrl, config, version, un, pw, configObj, image, where, callback) {
        var HR2 = new HandleResult();
        HR2.errorMessage = 'Unable to create new app';
        HR2.checkResult = function(response, result) {
            if (!result.success) {
                // TODO, the string comparison here can probably
                // be dropped
                if (result.errcode === 265 ||
                    result.errcode === '265') {
                    // prompt for choose an organization
                    var orgs = [],
                        orgids = [],
                        orgid;
                    for (orgid in result.organizations) {
                        if (result.organizations.hasOwnProperty(orgid)) {
                            orgids.push(orgid);
                            var org = '';
                            org += result.organizations[orgid].name;
                            org += (' (' + orgid + ')');
                            orgs.push(org);
                        }
                    }

                    console.log('You belong to more than one organization. Please choose one for the app.');
                    program.choose(orgs, function(i) {
                        var orgid = orgids[i];
                        console.log('Creating new Node.ACS app for organization ' + orgs[i] + '...');
                        // set the orgid for serverUrl
                        var parsedUrl = url.parse(serverUrl);
                        if (_.isEmpty(parsedUrl.query || {})) {
                            parsedUrl.query = {};
                        }
                        parsedUrl.query.orgid = orgid;
                        serverUrl = url.format(parsedUrl);
                        request({
                            uri: encodeURI(newAppURL),
                            method: 'POST',
                            proxy: proxy,
                            headers: {
                                'Cookie': cookie,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                orgid: orgid
                            })
                        }, HR2.handler);

                    });
                } else {
                    var message = result.extended || result.message;
                    u.die('Unable to create new app: ' + message, result.errcode ? result.errcode : 1);
                }
            } else {
                cli.spinner('Creating new Node.ACS app...done', true);
                cli.spinner('Preparing application for publish... done\n', true);
                if (where === 'dir') {
                    callback(dirs, serverUrl, config, cookie, version, un, pw);
                } else if (where === 'git') {
                    callback(serverUrl, configObj);
                } else if (where === 'image') {
                    callback(serverUrl, config.name, image, version);
                }
            }
        };

        var body = {};
        if (program.org) {
            body.orgid = program.org;
        }

        request({
            uri: encodeURI(newAppURL),
            method: 'POST',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        }, HR2.handler);

    }

    function unpublishApp(unpublishURL, dirs, serverUrl, config, version, un, pw, configObj, image, where, callback) {
        var HR2 = new HandleResult();
        
        if (program.org) {
            unpublishURL += ('?orgid=' + program.org);
        }

        HR2.succeed = function(response, result) {
            cli.spinner(result.message, true);
            if (where === 'dir') {
                callback(dirs, serverUrl, config, cookie, version, un, pw);
            } else if (where === 'git') {
                callback(serverUrl, configObj);
            } else if (where === 'image') {
                callback(serverUrl, config.name, image, version);
            }
        };

        request({
            uri: encodeURI(unpublishURL),
            method: 'POST',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HR2.handler);
    }
};

function publish(dirs, serverUrl, config, cookie, version, un, pw) {
    post.sendTarGz(dirs, serverUrl, config.version, un, pw, handlePublishResult, cookie);
}


/**
 * This function will get the docker registrl URL from stratus first,
 * then tag the docker image provided by user based on the rule:
 *   dockerRegistralURL/orgid/appname:version
 * after that, it will push the image to the remote docker registry
 * finally, it will send the publish request to stratus
 */
function pushImageAndPublish(serverUrl, appname, image, version) {
   
    var p,
        PushURL,
        globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if(proxy) {
        proxy = proxy.url;
    }

    var parsedUrl = url.parse(serverUrl),
        orgid = null;
    if (parsedUrl.query && parsedUrl.query.orgid) {
        orgid = parsedUrl.query.orgid;
    }

    var cookie = globalConfig.cookie ? String(globalConfig.cookie).split(';')[0] || [ 'connect-sid', '' ].join('=') : '';
    var username = globalConfig.username;

    p = '/push/' + appname + '/';

    PushURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' + (globalConfig.publishPort || defaultConfig.publishPort) + p;

    if(orgid) {
        PushURL += ('?orgid=' + orgid);
    }

    var HR = new HandleResult();
    HR.checkResult = function(response, result) {
        if (!result.success) {
            if (result.message) {
                u.die(result.message + ' ' + (result.extended || ''), result.errcode ? result.errcode : 1);
            } else {
                u.die('Failed to retrieve docker registry url: ' + result);
            }   
        }
        
        var dockerRegistryURL = result.dockerRegistryURL;
        var protocol = result.protocol;
        var orgs = [], orgids = [], orgid;
        for(orgid in result.appOrgs) {
            if(result.appOrgs.hasOwnProperty(orgid)) {
                orgids.push(orgid);
                var org = '';
                org += result.appOrgs[orgid].name;
                org += (' (' + orgid + ')');
                orgs.push(org);
            }
        }

        var appOrg, appOrgid;
        if (orgids.length > 1) {
            console.log('There are more than one apps named ' + appname + '. Please choose one to push image for.');
            program.choose(orgs, function(i) {
                appOrgid = orgids[i];
                appOrg = orgs[i];
            });
        } else {
            appOrgid = orgids[0];
            appOrg = orgs[0];
        }

        if (protocol === 'http:') {
            process.stdin.resume();
            program.prompt('It seems that the docker registry does not have https support, so you need to set ' + dockerRegistryURL + ' as insecure registry before continue. Proceed [yes/no]: ', function(val) {
                var value = val.trim().toLowerCase();
                if (['yes', 'y'].indexOf(value) >= 0) {
                    pushDockerImage();
                } else {
                    process.exit();  
                }
            });    
        } else {
            pushDockerImage();           
        }


        function pushDockerImage() { 
            console.log('Pushing image for app ' + appname + ' in organization ' + appOrg + '...');
            doPushDockerImage(image, appname, appOrgid, version, username, cookie, dockerRegistryURL, function(err) {
                if (err) {
                    u.die('Failed to push docker image to remote repo: ' + util.inspect(err)); 
                }

                var imageRepoNameRemote = dockerUtil.getImageRepoName(appname, orgid, dockerRegistryURL);
                
                var options = {
                    uri: encodeURI(serverUrl),
                    method: 'POST',
                    proxy: proxy,
                    headers: {
                        'Cookie': cookie,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({image: imageRepoNameRemote + ":" + version})
                };

                var Request = request(options, function(error, response, body) {

                    if (error) {
                        handlePublishResult(error);
                    }
                    if (response.statusCode === 503) {
                        handlePublishResult('Admin server is currently unavailable.');
                    }
                    if (response.statusCode === 502) {
                        handlePublishResult('Admin server ran into a problem when processing the request.');
                    }
                    if (response.statusCode !== 200) {
                        // XXX res is not defined, probably want to do something
                        // else here
                        handlePublishResult('Server returned error status. ' + response.statusCode);
                    }
                });

                var buf = '', progress = '';
                Request.on('data', function(b) {
                    progress += b;
                    var n, line;
                    while((n = progress.indexOf('|')) !== -1) {
                        if(n === 0) {
                            progress = progress.substring(1);
                        } else {
                            line = progress.substring(0, n);
                            progress = progress.substring(n);
                            if(line.indexOf('{') !== 0) {
                                console.log(line);
                            } else {
                                buf += line;
                            }
                        }
                    }
                });

                Request.on('end', function() {
                    buf += progress;
                    handlePublishResult(null, buf);
                });
            });
        }    
    };

    var options = {
        uri: encodeURI(PushURL),
        method: 'GET',
        proxy: proxy,
        headers: {
            'Cookie': cookie,
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    };

    request(options, HR.handler);    
}

function doPushDockerImage(image, appname, orgid, version, username, cookie, dockerRegistryURL, callback) {
    var imageRepoNameRemote = dockerUtil.getImageRepoName(appname, orgid, dockerRegistryURL);

    dockerUtil.tagDockerImage(image, imageRepoNameRemote, version, function(err) {
        if (err) {
            return callback(err);
        }
        var dockerRegistryAuthConfig = {
            "username": username,
            "password": cookie.substring(12, cookie.length),
            "auth":"",    // leave empty
            "email": username
        };

        console.log('Push docker image to registry: %s', imageRepoNameRemote+":"+version);

        dockerUtil.pushDockerImage(imageRepoNameRemote+":"+version, dockerRegistryAuthConfig, dockerRegistryURL, function(err) {
            if (err) {
                return callback(err);
            }
            dockerUtil.removeDockerImage(imageRepoNameRemote+":"+version, callback);
        });

    }); 
}


function handlePublishResult(err, buf) {
    if (err) {
        u.die('Error publishing app. ' + err);
    }
    try {
        var result = {};
        try {
            result = JSON.parse(buf);
        } catch (e) {
            u.die(buf);
        }
        if (!result.success) {
            if (result.meta) {
                console.log();
                u.die('Publish Error: ' + result.meta.message, result.errcode ? result.errcode : 1);
            } else {
                u.die('Publish Error: ' + result.message, result.errcode ? result.errcode : 1);
            }
        } else if (result.async) {
            console.log('App ' + result.name.blue + ' version ' + result.version.blue + ' starts to publish on cloud side. Please list app to check result.');
            process.exit();
        } else {
            if (result.name && result.version) {
                console.log('App ' + result.name.blue + ' version ' + result.version.blue + ' published.');
            } else {
                console.log('App published.');
            }
            if (result.url) {
                console.log('App will be available at ' + result.url.cyan);
                process.exit();
            }
        }
    } catch (E) {
        u.die('Error retrieving result ' + E + '. Result was ' + buf);
    }
}
