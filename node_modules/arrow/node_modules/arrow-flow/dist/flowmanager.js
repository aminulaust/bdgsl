'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint global-require:0 */
var Ajv = require('ajv');
var events = require('events');
var fs = require('fs');
var consoleLogger = require('./logger');
var Flow = require('./flow');
var jsonpath = require('jsonpath');
var jsonlint = require('json-lint');
var noderegistry = require('./noderegistry');
var path = require('path');
var chalk = require('chalk');

/**
 * The Flow manager.
 * @public
 * @class
 */

var FlowManager = function (_events$EventEmitter) {
	_inherits(FlowManager, _events$EventEmitter);

	/**
  * Create a server.
  * @constructor
  * @param {object} config - The global configuration that the flows can access.
  * @param {object} logger - The internal logger to use.
  */
	function FlowManager(config, logger) {
		_classCallCheck(this, FlowManager);

		var _this = _possibleConstructorReturn(this, (FlowManager.__proto__ || Object.getPrototypeOf(FlowManager)).call(this));

		_this.cache = {};

		_this.config = config;
		_this.setLogger(logger);

		var flowSchema = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'flowschema.json'), 'utf8'));
		_this.ajv = new Ajv();
		_this.ajv.addSchema(flowSchema, 'flowSchema');
		return _this;
	}

	/**
  * Sets the logger.  Set to `null` to use the default logger.
  * @public
  * @param {object} logger - The internal logger to use.
  */


	_createClass(FlowManager, [{
		key: 'setLogger',
		value: function setLogger(logger) {
			this.logger = logger || consoleLogger;
		}

		/**
   * Register a node handler.
   * @public
   * @param {string} type - The type of the node the handler will process.
   * @param {FlowNode} handler - The handler implementation.
   */

	}, {
		key: 'registerNode',
		value: function registerNode(type, handler) {
			this.logger.debug('Registering node handler ' + type);
			noderegistry.registerNode(type, handler);
		}

		/**
   * Return a map of the flow definitions by id.
   * @public
   * @returns {Object} A map of flow definitions by id.
   */

	}, {
		key: 'getFlows',
		value: function getFlows() {
			var _this2 = this;

			return Object.keys(this.cache).reduce(function (prev, cur) {
				prev[cur] = _this2.cache[cur].flow;
				return prev;
			}, {});
		}

		/**
   * Return the flow definition.
   * @public
   * @param {string} flowId - The flow to execute.
   * @returns {Object} The flow definition.
   */

	}, {
		key: 'getFlow',
		value: function getFlow(flowId) {
			return this.cache && this.cache[flowId] && this.cache[flowId].flow;
		}

		/**
   * Exceute the flow.
   * @public
   * @param {string} flowId - The flow to execute.
   * @param {object} data - The data to execute the flow with.
   * @returns {Promise} A promise that will be resolved with the final context when the
   *				   flow execution completes.
   */

	}, {
		key: 'flow',
		value: function flow(flowId, data) {
			if (!this.cache || !this.cache[flowId]) {
				this.logger.error('Flow not found: ' + flowId);
				throw Error('Flow not found: ' + flowId);
			}
			this.emit('preflow', flowId, data);
			this.logger.debug(chalk.dim('Invoking: ' + flowId));

			var promise = this.cache[flowId].invoke(data);
			this.emit('postflow', flowId, data, promise);
			return promise;
		}

		/**
   * Load the flow.
   * @public
   * @param {string} flowPath - The path to the flow json definition.
   * @returns {Promise} A promise that when resolved contains the loaded flow.
   */

	}, {
		key: 'load',
		value: function load(flowPath) {
			var _this3 = this;

			return new Promise(function (resolve, reject) {
				return fs.readFile(flowPath, function (err, data) {
					var name = path.basename(flowPath, path.extname(flowPath));

					if (err) {
						reject(err);
						return;
					}

					// Use linter to check for syntax errors.
					var lint = jsonlint(data.toString());
					if (lint.error) {
						reject(new Error('Unable to load flow ' + name + '. ' + lint.error + ' in ' + flowPath + ' at line ' + lint.line + ' character ' + lint.character));
						return;
					}

					// Parse and validate the flow.
					var flowDef = JSON.parse(data.toString());

					var valid = _this3.ajv.validate('flowSchema', flowDef);
					if (!valid) {
						reject('Unable to load flow ' + name + '. Syntax error in flow: ' + flowPath + ': ' + _this3.ajv.errorsText());
						return;
					}

					resolve(_this3._addFlow(name, flowDef));
				});
			});
		}

		/**
   * Add a flow to the cache.
   * @private
   * @param {string} flowId - The id for the flow.
   * @param {object} flowDef - The flow definition.
   */

	}, {
		key: '_addFlow',
		value: function _addFlow(flowId, flowDef) {
			this.cache = this.cache || {};
			var flow = this.cache[flowId] = new Flow(flowId, flowDef, this._env.bind(this), this.logger);
			if (flow.validation.valid) {
				this.emit('loaded', flow);
			} else {
				this.logger.error('Invalid flow ' + flowId + ': ' + JSON.stringify(flow.validation, null, 2));
				this.emit('invalidflow', flow);
			}
			return flow;
		}

		/**
   * Get values from the environment.
   * @private
   * @param {string} variable  - The JSON Path to evaluate against the config.
   * @returns The configuration value for the specified path.
   */

	}, {
		key: '_env',
		value: function _env(variable) {
			var val = jsonpath.query(this.config, variable);
			val = val && (val.length === 1 ? val[0] : val);
			return val;
		}
	}]);

	return FlowManager;
}(events.EventEmitter);

exports = module.exports = FlowManager;