'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint no-unused-expressions: 0 */
/* eslint no-multi-assign: 0 */
var jsonpath = require('jsonpath');

/**
 * JSON path expression is: `path|<index>`, where `|index` is optional.
 *
 * The first part of the JSON path `path` expression will always resolve to an
 * array.  If the optional `index` is not specified, then this function will
 * return the exact JSON path match.  If an `index` is provided, then this
 * function will return the value from the array at the specified `index`.  If
 * the `index` is outside the array range, then `undefined` is returned.
 */
var getByJsonPath = function getByJsonPath(expression, obj) {
	// match: path<|index>
	var parts = /(.+?)(?:\|(\d+))?$/.exec(expression),
	    // i.e. trailing |digits$
	key = parts[1],
	    index = parts[2] ? parseInt(parts[2], 10) : undefined;
	var val = void 0;

	if (!(obj instanceof Object)) {
		if (key === '$') {
			if (!(obj instanceof Array)) {
				// If the object passed in is not an Object or Array, it can be
				// something like a Number.  The JSON path query cannot handle it,
				// so emulate it by wrapping in array.
				val = [obj];
			} else {
				// in the case where `obj` is an Array and the expression is just
				// querying $, then the jsonpath will wrap the object in an additional
				// array.  E.g. [1,2] with $ will match: [[1,2]].  However, if $[1] is
				// used, then [2] is returned.  So, the value is just `obj`.
				val = obj;
			}
		} else {
			// `obj` is not an object and `key` is an expression, so no match
			val = [];
		}
	} else {
		val = jsonpath.query(obj, key);
	}

	if (index >= 0) {
		if (index < val.length) {
			val = val[index];
		} else {
			val = undefined;
		}
	}

	return val;
};

/**
 * Nested expansion of json path selectors in the value.
 *
 * @private
 * @param {object} val - The value being expanded.
 * @param {object} data - The data to use for the expansion.
 * @return {object} The expanded result.
 */
var expandSelectors = function expandSelectors(val, data) {
	var expanded = void 0;
	if (typeof val === 'string' && val.startsWith('$')) {
		expanded = getByJsonPath(val, data);
	} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
		expanded = {};
		Object.keys(val).forEach(function (key) {
			expanded[key] = expandSelectors(val[key], data);
		});
	} else {
		expanded = val;
	}
	return expanded;
};

var validateJsonPathSelector = function validateJsonPathSelector(expression) {
	if (!expression) {
		return null;
	}
	var parts = /(.+?)(?:\|(\d+))?$/.exec(expression); // i.e. trailing |digits$
	if (parts[1] === '$') {
		return null;
	}
	// FYI: parts[2] is the optional index, and is guaranteed to be a number
	try {
		jsonpath.parse(parts[1]);
	} catch (ex) {
		return {
			jsonpath: parts[1],
			error: ex.toString()
		};
	}
	return null;
};

/**
 * Validate all selectors contained in the value.
 */
var validateJsonPathSelectors = function validateJsonPathSelectors(val) {
	var errors = null;
	if (typeof val === 'string' && val.startsWith('$')) {
		var curErr = validateJsonPathSelector(val);
		if (curErr) {
			errors = errors ? [curErr].concat(_toConsumableArray(errors)) : [curErr];
		}
	} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
		Object.keys(val).forEach(function (key) {
			var curErrs = validateJsonPathSelectors(val[key]);
			if (curErrs) {
				errors = errors ? [].concat(_toConsumableArray(curErrs), _toConsumableArray(errors)) : curErrs;
			}
		});
	}
	return errors;
};

exports = module.exports = {
	getByJsonPath: getByJsonPath,
	validateJsonPathSelectors: validateJsonPathSelectors,
	validateJsonPathSelector: validateJsonPathSelector,
	expandSelectors: expandSelectors
};