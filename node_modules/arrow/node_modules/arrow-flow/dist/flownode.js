'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-unused-expressions:0 */
var getByJsonPath = require('./jsonpath').getByJsonPath;
var consoleLogger = require('./logger');

var FlowNode = function () {
	function FlowNode(name, node, flow) {
		_classCallCheck(this, FlowNode);

		this.node = node || {};
		this.config = this.node.config || {};
		this.name = name;
		this.flow = flow;
		this.logger = this.flow.logger || consoleLogger;
	}

	/**
  * Validate the node.
  * @returns {object} The node specific validation errors. Or null if valid.
  */


	_createClass(FlowNode, [{
		key: 'validate',
		value: function validate() {
			return null;
		}
	}, {
		key: 'invoke',
		value: function invoke(ctx) {
			var _this = this;

			var promise = new Promise(function (resolve, reject) {
				var callback = function callback(err, results) {
					if (err) {
						_this.logger.trace(_this.name + ' rejected.');
						reject(err);
					}
					_this.logger.trace(_this.name + ' resolved.');
					resolve(results);
				};
				try {
					var params = {};
					_this.node.parameters && _this.node.parameters.forEach(function (param) {
						var val = param.value;
						var defaultVal = param.default;
						if (typeof val === 'string') {
							val = getByJsonPath(val, ctx.data);
						}
						if (val !== undefined || defaultVal !== undefined) {
							params[param.name] = val !== undefined ? val : defaultVal;
						}
						// useful for debugging parameters:
						// this.logger.trace(
						//	chalk.dim('  resolved param:'), param.name, chalk.dim('as:'), JSON.stringify(val));
					});
					_this.action ? _this.action(_this.flow.env, params, callback) : resolve();
				} catch (err) {
					_this.logger.trace(_this.name + ' rejected: ' + err);
					reject(err);
				}
			});

			return promise;
		}
	}]);

	return FlowNode;
}();

exports = module.exports = FlowNode;