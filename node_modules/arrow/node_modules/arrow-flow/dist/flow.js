'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-console:0 */
/* eslint no-multi-assign:0 */
var chalk = require('chalk');
var consoleLogger = require('./logger');

var _require = require('./jsonpath'),
    getByJsonPath = _require.getByJsonPath,
    expandSelectors = _require.expandSelectors;

var noderegistry = require('./noderegistry');
var flowvalidate = require('./flowvalidate');

var CONDITION_OPERATORS = {
	eq: function eq(key, value) {
		return key === value;
	},
	ne: function ne(key, value) {
		return key !== value;
	},
	exists: function exists(key, value) {
		return key ? value : !value;
	},
	lt: function lt(key, value) {
		return key < value;
	},
	le: function le(key, value) {
		return key <= value;
	},
	gt: function gt(key, value) {
		return key > value;
	},
	ge: function ge(key, value) {
		return key >= value;
	}
};

/**
 * An invokable Flow.
 * @public
 * @class
 */

var Flow = function () {

	/**
  * Create a flow.
  * @constructor
  * @param {string} flowId - The id of this flow.
  * @param {object} flowdef - The flow definition.
  * @param {function} env - Access environment variables.
  * @param {Logger} logger - The logger.
  */
	function Flow(flowId, flowdef, env, logger) {
		_classCallCheck(this, Flow);

		this.id = flowId;
		this.logger = logger || consoleLogger;
		this.nodes = {};
		this.env = env;
		this._parseFlow(flowdef);
	}

	/**
  * Invoke this flow with the specified context.
  *
  * @public
  * @param {object} data - The initial data to execute the flow with.
  * @returns {Promise} A promise that will be resolved with the final context when the
  *					flow execution completes.
  */


	_createClass(Flow, [{
		key: 'invoke',
		value: function invoke(data) {
			var _this = this;

			var ctx = {
				runtime: {
					paths: {
						reverse: JSON.parse(JSON.stringify(this.nodeInfo.paths.reverse))
					}
				},
				data: data
			};

			var terminationPromise = null;
			if (this.validation.valid) {
				// Starts flow execution and returns a promise that will wait on
				// termination of all branches of flow.
				terminationPromise = new Promise(function (resolve, reject) {
					try {
						var terminatorPromises = [];

						_this.nodeInfo.terminalNodes.forEach(function (nodeName) {
							terminatorPromises.push(_this._getNodeExecutionPromise(ctx, nodeName));
						});

						Promise.all(terminatorPromises).then(function () {
							var returns = void 0;
							if (_this.flow.returns) {
								returns = expandSelectors(_this.flow.returns, ctx.data);
							}
							return resolve(returns);
						}).catch(function (err) {
							return reject(err);
						});

						// Execute the flow.
						_this._invokeNodes(ctx, [_this.nodes[_this.flow.start]]);
					} catch (err) {
						reject(err);
					}
				});
			} else {
				// Abort the flow immediately if not valid.
				terminationPromise = new Promise(function (resolve, reject) {
					reject(_this.validation);
				});
			}

			// Abort execution before the completion of the flow
			var abortPromise = this._getNodeExecutionPromise(ctx, '$$.abort').catch(function (err) {
				ctx.runtime.flowAborted = true;
				throw err;
			});

			// Race - on error abort the flow, otherwise wait until all nodes complete.
			return Promise.race([abortPromise, terminationPromise]);
		}

		/**
   * Parse the flow definition.
   *
   * @private
   * @param {string} flowdef - The flow json to load or the object for the flow.
   */

	}, {
		key: '_parseFlow',
		value: function _parseFlow(flowdef) {
			var _this2 = this;

			if (typeof flowdef === 'string') {
				this.flow = JSON.parse(flowdef);
			} else {
				this.flow = flowdef;
			}

			// Process the nodes in the graph to determine parential dependencies and
			// nodes that terminate the flow.
			this.nodeInfo = {
				terminalNodesMap: {},
				nodes: {},
				paths: {
					reverse: {}
				}
			};

			Object.keys(this.flow.nodes).forEach(function (nodeKey) {
				var node = _this2.flow.nodes[nodeKey];

				node.response.routes.forEach(function (route) {
					var info = _this2.nodeInfo.nodes[nodeKey] = _this2.nodeInfo.nodes[nodeKey] || {};

					info.parents = info.parents || [];
					info.children = info.children || [];

					// Children
					if (route.next != null) {
						if (Array.isArray(route.next)) {
							info.children = (info.children || []).concat(route.next);
						} else {
							info.children.push(route.next);
						}
					} else {
						_this2.nodeInfo.terminalNodesMap[nodeKey] = true;
					}

					// Parents
					info.children.forEach(function (childKey) {
						var nodeInfo = _this2.nodeInfo.nodes[childKey] = _this2.nodeInfo.nodes[childKey] || {};
						nodeInfo.parents = nodeInfo.parents || [];
						nodeInfo.parents.push(nodeKey);
					});

					// Add the reverse paths
					info.parents.forEach(function (parent) {
						_this2.nodeInfo.paths.reverse[nodeKey] = _this2.nodeInfo.paths.reverse[nodeKey] || {};
						_this2.nodeInfo.paths.reverse[nodeKey][parent] = true;
					});
				});

				// Create the nodes for the flow:
				_this2.nodes[nodeKey] = noderegistry.create(nodeKey, node, _this2);
			});

			// Convert terminal nodes to array
			this.nodeInfo.terminalNodes = Object.keys(this.nodeInfo.terminalNodesMap);
			delete this.nodeInfo.terminalNodesMap;

			// Validate the flow - check all the nodes, no cycles, syntax, etc.
			// Update the definition to make validation report available to clients
			this.validation = flowvalidate(this);
			this.flow['x-validation'] = this.validation;
		}

		/**
   * This method handles invoke the nodes when they are ready and processing the result from the
   * node invocation when it's complete.
   *
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {object[]} nodes - The nodes to execute.
   */

	}, {
		key: '_invokeNodes',
		value: function _invokeNodes(ctx, nodes) {
			var _this3 = this;

			if (!nodes || nodes.length === 0) {
				// Branch is complete
				return;
			}

			nodes.forEach(function (node) {
				_this3._invokeWhenReady(ctx, node).then(function (result) {
					return _this3._createNodeResponseContext(ctx, node, result);
				}, function (err) {
					_this3.logger.trace(node.name + ' rejected: ' + err);
					throw err;
				}).then(function (respCtx) {
					return _this3._stopOnAbort(respCtx);
				}).then(function (respCtx) {
					return _this3._updateContext(respCtx);
				}).then(function (respCtx) {
					return _this3._selectRoute(respCtx);
				}).then(function (respCtx) {
					return _this3._resolveExecutionPromise(respCtx);
				}).then(function (respCtx) {
					return _this3._pruneUnexecutableBranches(respCtx);
				}).then(function (respCtx) {
					return _this3._invokeNext(respCtx);
				}).catch(function (err) {
					_this3.logger.debug(chalk.dim('Aborting flow:', err), err.stack);
					_this3._getNodeExecutionPromise(ctx, '$$.abort').reject(err);
				});
			});
		}

		/**
   * A node must wait until it is invocable before it can be invoked. This method
   * returns a promise that is resolved when the node is invokable and that
   * invocation completes.
   *
   * A node is considered invocable if all paths to this node have been completed
   * (i.e. all parent nodes have completed.)
   *
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {object} node - The nodes to execute.
   */

	}, {
		key: '_invokeWhenReady',
		value: function _invokeWhenReady(ctx, node) {
			var _this4 = this;

			this.logger.debug(chalk.dim('Waiting:', node.name));

			var nodePromise = new Promise(function (resolve) {
				Promise.all(_this4._getNodeParentExecutionPromises(ctx, node.name)).then(function () {
					_this4.logger.debug(chalk.dim('Invoking:', node.name));
					resolve(node.invoke(ctx));
				});
			});

			return Promise.race([this._getNodeExecutionPromise(ctx, '$$.abort'), nodePromise]);
		}

		/**
   * Create a response context for use in the chain that processes the invoke() response.
   * The response context is:
   * {
   *	flowAborted: boolean,
   *	ctx: context,
   *	node: object,
   *	result: object,
   *	next: array
   * }
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {string} node - The node name.
   * @param {object} result - The node invoke result.
   * @returns {object} An object with the necessary information for further processing.
   */

	}, {
		key: '_createNodeResponseContext',
		value: function _createNodeResponseContext(ctx, node, result) {
			return {
				flowAborted: !!ctx.runtime.flowAborted,
				ctx: ctx,
				node: node,
				result: result,
				next: []
			};
		}

		/**
   * Short circuit processing if the flow has been aborted.
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_stopOnAbort',
		value: function _stopOnAbort(responseCtx) {
			if (responseCtx.flowAborted) {
				throw new Error('Aborted');
			}
			return responseCtx;
		}

		/**
   * Get the promise that will be resolved when the node is executed.
   *
   * @private
   * @param {object} ctx - The context - execution promises are stored in the context.
   * @param {string} nodeName - The name of the node to get the promise for.
   * @returns {Promise} The execution promise for nodeName.
   */

	}, {
		key: '_getNodeExecutionPromise',
		value: function _getNodeExecutionPromise(ctx, nodeName) {
			ctx.runtime = ctx.runtime || {};
			var promises = ctx.runtime.promises = ctx.runtime.promises || {};

			if (!promises[nodeName]) {
				var getPromise = function getPromise() {
					var execResolve = null;
					var execReject = null;

					var promise = new Promise(function (resolve, reject) {
						execResolve = resolve;
						execReject = reject;
					});
					promise.resolve = execResolve;
					promise.reject = execReject;
					return promise;
				};

				promises[nodeName] = getPromise();
			}

			return promises[nodeName];
		}

		/**
   * Get the promises that will be resolved when the nodes parents are executed.
   *
   * @private
   * @param {object} ctx - The context - execution promises are stored in the context.
   * @param {string} nodeName - The name of the node whose parent promises are being requested.
   * @returns {Promise[]} An array containing the execution promises for nodeNames parent nodes.
   */

	}, {
		key: '_getNodeParentExecutionPromises',
		value: function _getNodeParentExecutionPromises(ctx, nodeName) {
			var _this5 = this;

			var parentPromises = [];
			this.nodeInfo.nodes[nodeName].parents.forEach(function (parent) {
				parentPromises.push(_this5._getNodeExecutionPromise(ctx, parent));
			});
			return parentPromises;
		}

		/**
   * Convenience method to resolve the nodes promise in a thenable chain.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_resolveExecutionPromise',
		value: function _resolveExecutionPromise(responseCtx) {
			this._getNodeExecutionPromise(responseCtx.ctx, responseCtx.node.name).resolve();
			return responseCtx;
		}

		/**
   * Update the context with the result from the node execution.
   *
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_updateContext',
		value: function _updateContext(responseCtx) {
			var _this6 = this;

			var nodeconfig = responseCtx.node.node;
			var contextTargets = nodeconfig.response.context;

			if (responseCtx.result !== undefined) {
				var result = responseCtx.result;

				Object.keys(contextTargets).forEach(function (ctxpath) {
					var target = contextTargets[ctxpath];
					var value = getByJsonPath(ctxpath, result);

					_this6.logger.debug(chalk.green(' ', responseCtx.node.name), chalk.dim('writing'), chalk.yellow(JSON.stringify(value)), chalk.dim('to ctx as:'), chalk.cyan(target));

					if (Array.isArray(target)) {
						target.forEach(function (as) {
							if (_this6._testCtxTarget(as)) {
								responseCtx.ctx.data[as] = value;
							}
						});
					} else if (_this6._testCtxTarget(target)) {
						responseCtx.ctx.data[target] = value;
					}
				});
			}

			return responseCtx;
		}

		/**
   * Test the target value name. If it's a basic name (alpha-first a-z 0-9 A-Z) it's valid.
   *
   * @private
   * @param {object} target - The property name to test
   * @returns If the target is a valid prop for the context
   */

	}, {
		key: '_testCtxTarget',
		value: function _testCtxTarget(target) {
			// Make sure that the key is a basic name.
			var pass = /^[A-Z|a-z]+[0-9|A-Z|a-z]*$/g.test(target);
			if (!pass) {
				this.logger.error('Error: cannot write ' + target + ' to the context. Invalid value');
			}
			return pass;
		}

		/**
   * Evaluate the route matchers and update the response context with the
   * nodes that will be executed next.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_selectRoute',
		value: function _selectRoute(responseCtx) {
			var _this7 = this;

			var nodeconfig = responseCtx.node.node;
			var routes = nodeconfig.response.routes;
			var result = responseCtx.result;

			var route = routes.find(function (routeselector) {
				var match = false;

				if (!routeselector.conditions || !routeselector.conditions.length) {
					match = true; // No test required.
				} else {
					// Compare all of the route conditions and if all match, then the route is a match.
					match = routeselector.conditions.every(function (condition) {
						var keyVal = getByJsonPath(condition.key, result);
						// schema and validation demands that this `op` exists, but need to
						// go through all keys on `condition` to identify the op.
						var op = Object.keys(condition).find(function (a) {
							return CONDITION_OPERATORS.hasOwnProperty(a);
						});
						var respValue = typeof condition[op] === 'string' && condition[op].startsWith('$') ? getByJsonPath(condition[op], result) : condition[op];

						match = CONDITION_OPERATORS[op](keyVal, respValue);

						_this7.logger.trace(' ', chalk.green(responseCtx.node.name), chalk.dim('testing route condition: "' + keyVal + ' ' + op + ' ' + respValue + '" ' + (match ? '(matched)' : '')));

						return match;
					});
				}

				return match;
			});

			if (!route) {
				throw new Error('abnormal flow termination - failed to find a matching route: ' + responseCtx.node.name);
			}

			if (route) {
				responseCtx.next = Array.isArray(route.next) ? route.next : route.next && [route.next] || [];
			}
			this.logger.debug(' ', chalk.green(responseCtx.node.name), 'route:', chalk.dim(JSON.stringify(responseCtx.next)));

			return responseCtx;
		}

		/**
   * Remove the paths that are no longer executable.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_pruneUnexecutableBranches',
		value: function _pruneUnexecutableBranches(responseCtx) {
			var inactivePaths = this.nodeInfo.nodes[responseCtx.node.name].children.filter(function (child) {
				return responseCtx.next.indexOf(child) === -1;
			}).map(function (child) {
				return { source: responseCtx.node.name, target: child };
			});
			this._cutInactivePath(responseCtx.ctx, inactivePaths);
			return responseCtx;
		}

		/**
   * Remove the paths that are no longer active.
   *
   * @private
   * @param {object} ctx - The flow context.
   * @param {(object[]|string)} inactivePaths - The list of paths that are no longer
   *		active. If a single node name is specified then all children are cut.
   * @param {string} inactivePaths[].source - The source node.
   * @param {string} inactivePaths[].target - The target node.
   */

	}, {
		key: '_cutInactivePath',
		value: function _cutInactivePath(ctx, inactivePaths) {
			var _this8 = this;

			if (!inactivePaths) {
				return;
			} else if (typeof inactivePaths === 'string' || inactivePaths instanceof String) {
				// All children of the specified node
				inactivePaths = this.nodeInfo.nodes[inactivePaths].children.map(function (child) {
					return { source: inactivePaths, target: child };
				});
			}

			if (!inactivePaths.length) {
				return;
			}

			var reversePaths = ctx.runtime.paths.reverse;

			// Filter out the inactive paths from the runtime graph
			inactivePaths.forEach(function (path) {
				if (reversePaths[path.target] && reversePaths[path.target][path.source]) {
					delete reversePaths[path.target][path.source];
					if (!Object.keys(reversePaths[path.target]).length) {
						// No more paths to this node so resolve it's execution promise and clean up.
						delete reversePaths[path.target];
						_this8._getNodeExecutionPromise(ctx, path.target).resolve();
						_this8._cutInactivePath(ctx, path.target);
					}
				}
			});
		}

		/**
   * Invoke the next nodes, called after updateContext (which detects the next nodes).
   * Note nodes will only be invoked once.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns The response context for this invocation (to support chaining).
   */

	}, {
		key: '_invokeNext',
		value: function _invokeNext(responseCtx) {
			var _this9 = this;

			var ctx = responseCtx.ctx;
			var pending = ctx.pending = ctx.pending || {};
			var nextNodeKeys = responseCtx.next;
			var nextNodes = [];

			// Invoke the next node if it's not already pending
			nextNodeKeys.forEach(function (nodeKey) {
				if (!pending.hasOwnProperty(nodeKey)) {
					var next = _this9.nodes[nodeKey];
					nextNodes.push(next);
					pending[nodeKey] = true;
				}
			});

			this._invokeNodes(ctx, nextNodes);

			return responseCtx;
		}
	}]);

	return Flow;
}();

exports = module.exports = Flow;