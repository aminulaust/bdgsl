'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-unused-expressions:0 */
/* eslint no-multi-assign:0 */
var _require = require('./jsonpath'),
    validateJsonPathSelectors = _require.validateJsonPathSelectors,
    validateJsonPathSelector = _require.validateJsonPathSelector;

/**
 * Helper for validating flows. The validation checks for:
 * - no cyclical loops
 * - no undefined nodes in the routing
 *
 * @private
 * @class
 */


var FlowValidator = function () {
	/**
 * Create a flow validator.
 * @constructor
 * @param {Flow} flow - The flow to validate.
 */
	function FlowValidator(flow) {
		_classCallCheck(this, FlowValidator);

		this.flow = flow;
		this.index = 0;
		this.undefinedNodes = [];
		this.vertices = this._initVerts(flow);
	}

	/**
 * Pre-process the nodes in the flow to create a graph of verticies
 * to allow for loop detection.
 *
 * @private
 * @returns {object} A map of pre-processed verticies by node name.
 */


	_createClass(FlowValidator, [{
		key: '_initVerts',
		value: function _initVerts() {
			var _this = this;

			var vertices = Object.keys(this.flow.nodes).reduce(function (prev, cur) {
				prev[cur] = {
					name: cur,
					node: _this.flow.nodes[cur].node,
					index: null,
					connections: []
				};
				return prev;
			}, {});

			// Initialize the connections.
			Object.keys(vertices).forEach(function (name) {
				var _vertex$connections;

				var vertex = vertices[name];
				var conns = {};

				vertex.node.response.routes.forEach(function (route) {
					if (route.next) {
						var next = route.next;
						if (typeof next === 'string') {
							next = [next];
						}

						next.forEach(function (n) {
							var vert = vertices[n];
							if (!vert) {
								_this.undefinedNodes.push({
									node: vertex.name,
									target: n
								});
							} else {
								conns[n] = vertices[n];
							}
						});
					}
					// NOTE: schema validation already checks that `conditions` is an
					// optional array, and that they have a valid operator.
				});

				(_vertex$connections = vertex.connections).push.apply(_vertex$connections, _toConsumableArray(Object.keys(conns).map(function (n) {
					return conns[n];
				})));
			});

			return vertices;
		}

		/**
   * Using 'Tarjan's strongly connected components algorithm' to group strongly
   * conencted nodes (loops).
   *
   * @private
   * @param {object} vertex - The node/vertex to process.
   * @param {array} stack - The stack for vertex processing.
   * @param {array} stronglyConnectedGroups - The resulting list of strongly connected groups.
   */

	}, {
		key: '_strongconnect',
		value: function _strongconnect(vertex, stack, stronglyConnectedGroups) {
			var _this2 = this;

			vertex.index = this.index;
			vertex.lowlink = this.index;
			this.index += 1;
			stack.push(vertex);
			vertex.onStack = true;

			vertex.connections.forEach(function (w) {
				if (w.index === null) {
					_this2._strongconnect(w, stack, stronglyConnectedGroups);
					vertex.lowlink = Math.min(vertex.lowlink, w.lowlink);
				} else if (w.onStack) {
					vertex.lowlink = Math.min(vertex.lowlink, w.lowlink);
				}
			});

			if (vertex.lowlink === vertex.index) {
				var stronglyConnectedVerts = [];
				if (stack.length > 0) {
					var w = null;
					do {
						w = stack.pop();
						w.onStack = false;
						stronglyConnectedVerts.push(w);
					} while (w !== vertex);

					stronglyConnectedGroups.push(stronglyConnectedVerts);
				}
			}
		}

		/**
   * Check for any closed loops in the graph.
   * If there are loops loop chains are stored in validationErrors.loops.
   *
   * @private
   * @param {object} validationErrors - The object to add the validation errors to.
   * @returns {boolean} true if there are loops detected.
   */

	}, {
		key: 'checkForLoops',
		value: function checkForLoops(validationErrors) {
			var _this3 = this;

			var stack = [];
			var stronglyConnected = [];
			Object.keys(this.vertices).forEach(function (v) {
				var vertex = _this3.vertices[v];
				if (vertex.index === null) {
					_this3._strongconnect(vertex, stack, stronglyConnected);
				}
			});

			var loops = stronglyConnected.filter(function (g) {
				return g.length > 1 || g.length === 1 && g[0].connections[0] === g[0];
			});

			if (loops.length > 0) {
				validationErrors.valid = false;
				validationErrors.loops = [];

				loops.forEach(function (g) {
					validationErrors.loops.push(g.map(function (n) {
						return n.name;
					}));
				});
			}

			return loops.length > 0;
		}

		/**
   * Check nodes that have connections to non-existent targets.
  	 * If there are undefined connections the details are are stored in
   * validationErrors.undefinedNodes.
  	 *
  	 * @private
  	 * @param {object} validationErrors - The object to add the validation errors to.
  	 * @returns {boolean} true if there are undefined nodes detected.
  	 */

	}, {
		key: 'checkForUndefinedNodes',
		value: function checkForUndefinedNodes(validationErrors) {
			if (this.undefinedNodes.length > 0) {
				validationErrors.undefinedNodes = [].concat(_toConsumableArray(this.undefinedNodes));
			}

			if (!this.flow.nodes[this.flow.flow.start]) {
				validationErrors.undefinedNodes = validationErrors.undefinedNodes || [];
				validationErrors.undefinedNodes.push({ node: null, target: this.flow.flow.start });
			}
			validationErrors.valid = validationErrors.valid && !validationErrors.undefinedNodes;

			return validationErrors.valid;
		}

		/**
   * Check that the flow nodes are valid.
  	 * If there are undefined connections the details are are stored in
   * validationErrors.node[name].
  	 *
  	 * @private
  	 * @param {object} validationErrors - The object to add the validation errors to.
  	 * @returns {boolean} true if there are invalid nodes detected.
  	 */

	}, {
		key: 'checkNodes',
		value: function checkNodes(validationErrors) {
			var _this4 = this;

			var validResponseContextTarget = /^[a-zA-Z][a-zA-Z0-9]*$/;

			Object.keys(this.flow.nodes).forEach(function (n) {
				var node = _this4.flow.nodes[n];
				var nodeErrors = node.validate();

				// Node response context targets must be alphanumeric and valid selectors
				var responseContext = node.node.response.context;
				Object.keys(responseContext).forEach(function (rc) {
					var targets = responseContext[rc];
					if (typeof targets === 'string') {
						targets = [targets];
					}

					targets && targets.forEach(function (t) {
						if (!validResponseContextTarget.exec(t)) {
							nodeErrors = nodeErrors || {};
							nodeErrors.invalidResponseContext = nodeErrors.invalidResponseContext || [];
							nodeErrors.invalidResponseContext.push({ key: rc, value: t });
						}
					});
					var err = validateJsonPathSelector(rc);
					if (err) {
						nodeErrors = nodeErrors || {};
						nodeErrors.invalidResponseContext = nodeErrors.invalidResponseContext || [];
						nodeErrors.invalidResponseContext.push({ key: rc, error: err.error });
					}
				});

				// Node parameter values must be valid JSON path expressions
				node.node.parameters && node.node.parameters.forEach(function (param) {
					if (typeof param.value === 'string') {
						var err = validateJsonPathSelector(param.value);
						if (err) {
							nodeErrors = nodeErrors || {};
							nodeErrors.invalidJsonPathSelector = nodeErrors.invalidJsonPathSelector || [];
							nodeErrors.invalidJsonPathSelector.push({ param: param.name, jsonpath: err.jsonpath, error: err.error });
						}
					}
				});

				if (nodeErrors) {
					validationErrors.valid = false;
					validationErrors.node = validationErrors.node || {};
					validationErrors.node[n] = nodeErrors;
				}
			});

			return validationErrors.valid;
		}

		/**
   * Check that `returns` is a valid JSON path selector.
   * If there are undefined connections the details are are stored in
   * validationErrors.nodeErrors.
   *
   * @private
   * @param {object} validationErrors - The object to add the validation errors to.
   * @returns {boolean} true if there are invalid nodes detected.
   */

	}, {
		key: 'checkReturns',
		value: function checkReturns(validationErrors) {
			var returns = this.flow.flow.returns;
			if (returns === null || returns === undefined) {
				return true;
			}

			var errs = validateJsonPathSelectors(returns);
			if (errs) {
				validationErrors.valid = false;
				validationErrors.returns = errs.map(function (err) {
					return { jsonpath: err.jsonpath, error: err.error };
				});
			}
			return validationErrors.valid;
		}

		/**
   * Run all checks on the flow and report any validation errors.
  	 */

	}, {
		key: 'validate',
		value: function validate() {
			var validationErrors = { valid: true };
			this.checkForUndefinedNodes(validationErrors);
			this.checkForLoops(validationErrors);
			this.checkNodes(validationErrors);
			this.checkReturns(validationErrors);
			return validationErrors;
		}
	}]);

	return FlowValidator;
}();

/**
 * Run all checks on the flow and report any validation errors.
 *
 * @public
 * @param {Flow} flow - The flow to validate.
 */


function validate(flow) {
	return new FlowValidator(flow).validate();
}

exports = module.exports = validate;